## Classes

<dl>
<dt><a href="#Builder">Builder</a></dt>
<dd><p>Builds metadata from a template using market specific customisation</p>
</dd>
<dt><a href="#Deployer">Deployer</a></dt>
<dd><p>Reads metadata from local directory and deploys it to specified target business unit.
Source and target business units are also compared before the deployment to apply metadata specific patches.</p>
</dd>
<dt><a href="#Mcdev">Mcdev</a></dt>
<dd><p>main class</p>
</dd>
<dt><a href="#AccountUser">AccountUser</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>MessageSendActivity MetadataType</p>
</dd>
<dt><a href="#Asset">Asset</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>FileTransfer MetadataType</p>
</dd>
<dt><a href="#AttributeGroup">AttributeGroup</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>AttributeGroup MetadataType</p>
</dd>
<dt><a href="#Automation">Automation</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>Automation MetadataType</p>
</dd>
<dt><a href="#Campaign">Campaign</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>Campaign MetadataType</p>
</dd>
<dt><a href="#ContentArea">ContentArea</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>ContentArea MetadataType</p>
</dd>
<dt><a href="#DataExtension">DataExtension</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>DataExtension MetadataType</p>
</dd>
<dt><a href="#DataExtensionField">DataExtensionField</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>DataExtensionField MetadataType</p>
</dd>
<dt><a href="#DataExtensionTemplate">DataExtensionTemplate</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>DataExtensionTemplate MetadataType</p>
</dd>
<dt><a href="#DataExtract">DataExtract</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>DataExtract MetadataType</p>
</dd>
<dt><a href="#DataExtractType">DataExtractType</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>DataExtractType MetadataType
Only for Caching No retrieve/upsert is required
as this is a configuration in the EID</p>
</dd>
<dt><a href="#Discovery">Discovery</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>ImportFile MetadataType</p>
</dd>
<dt><a href="#Email">Email</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>Email MetadataType</p>
</dd>
<dt><a href="#EmailSendDefinition">EmailSendDefinition</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>MessageSendActivity MetadataType</p>
</dd>
<dt><a href="#EventDefinition">EventDefinition</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>EventDefinition MetadataType</p>
</dd>
<dt><a href="#FileTransfer">FileTransfer</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>FileTransfer MetadataType</p>
</dd>
<dt><a href="#Filter">Filter</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>Filter MetadataType</p>
</dd>
<dt><a href="#Folder">Folder</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>Folder MetadataType</p>
</dd>
<dt><a href="#FtpLocation">FtpLocation</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>ImportFile MetadataType</p>
</dd>
<dt><a href="#ImportFile">ImportFile</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>ImportFile MetadataType</p>
</dd>
<dt><a href="#Interaction">Interaction</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>Script MetadataType</p>
</dd>
<dt><a href="#List">List</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>List MetadataType</p>
</dd>
<dt><a href="#MetadataType">MetadataType</a></dt>
<dd><p>MetadataType class that gets extended by their specific metadata type class.
Provides default functionality that can be overwritten by child metadata type classes</p>
</dd>
<dt><a href="#MobileCode">MobileCode</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>MobileCode MetadataType</p>
</dd>
<dt><a href="#MobileKeyword">MobileKeyword</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>MobileKeyword MetadataType</p>
</dd>
<dt><a href="#Query">Query</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>Query MetadataType</p>
</dd>
<dt><a href="#Role">Role</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>ImportFile MetadataType</p>
</dd>
<dt><a href="#Script">Script</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>Script MetadataType</p>
</dd>
<dt><a href="#SetDefinition">SetDefinition</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>SetDefinition MetadataType</p>
</dd>
<dt><a href="#TriggeredSendDefinition">TriggeredSendDefinition</a> ⇐ <code><a href="#MetadataType">MetadataType</a></code></dt>
<dd><p>MessageSendActivity MetadataType</p>
</dd>
<dt><a href="#Retriever">Retriever</a></dt>
<dd><p>Retrieves metadata from a business unit and saves it to the local filesystem.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#Util">Util</a></dt>
<dd><p>CLI entry for SFMC DevTools</p>
</dd>
<dt><a href="#MetadataTypeDefinitions">MetadataTypeDefinitions</a></dt>
<dd><p>Provides access to all metadataType classes</p>
</dd>
<dt><a href="#MetadataTypeInfo">MetadataTypeInfo</a></dt>
<dd><p>Provides access to all metadataType classes</p>
</dd>
<dt><a href="#mcdev">mcdev</a></dt>
<dd><p>sample file on how to retrieve a simple changelog to use in GUIs or automated processing of any kind</p>
</dd>
<dt><a href="#SDK">SDK</a> : <code><a href="#SDK">SDK</a></code></dt>
<dd></dd>
<dt><a href="#BusinessUnit">BusinessUnit</a></dt>
<dd><p>Helper that handles retrieval of BU info</p>
</dd>
<dt><a href="#Cli">Cli</a></dt>
<dd><p>CLI helper class</p>
</dd>
<dt><a href="#DevOps">DevOps</a></dt>
<dd><p>DevOps helper class</p>
</dd>
<dt><a href="#File">File</a></dt>
<dd><p>File extends fs-extra. It adds logger and util methods for file handling</p>
</dd>
<dt><a href="#Init">Init</a></dt>
<dd><p>CLI helper class</p>
</dd>
<dt><a href="#Init">Init</a></dt>
<dd><p>CLI helper class</p>
</dd>
<dt><a href="#Init">Init</a></dt>
<dd><p>CLI helper class</p>
</dd>
<dt><a href="#Init">Init</a></dt>
<dd><p>CLI helper class</p>
</dd>
<dt><a href="#Util">Util</a></dt>
<dd><p>Util that contains logger and simple util methods</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#getUserName">getUserName(userList, item, fieldname)</a> ⇒ <code>string</code></dt>
<dd></dd>
<dt><a href="#createNewLoggerTransport">createNewLoggerTransport()</a> ⇒ <code>object</code></dt>
<dd><p>wrapper around our standard winston logging to console and logfile</p>
</dd>
<dt><a href="#startLogger">startLogger()</a> ⇒ <code>void</code></dt>
<dd><p>initiate winston logger</p>
</dd>
</dl>

## Typedefs

<dl>
<dt><a href="#CodeExtractItem">CodeExtractItem</a> : <code>Object.&lt;string, any&gt;</code></dt>
<dd></dd>
<dt><a href="#AutomationMap">AutomationMap</a> : <code>Object</code></dt>
<dd><p>REST format</p>
</dd>
<dt><a href="#DataExtensionMap">DataExtensionMap</a> : <code>Object</code></dt>
<dd></dd>
<dt><a href="#DataExtensionFieldMap">DataExtensionFieldMap</a> : <code>Object</code></dt>
<dd></dd>
<dt><a href="#CodeExtract">CodeExtract</a> : <code>Object</code></dt>
<dd></dd>
<dt><a href="#CodeExtractItem">CodeExtractItem</a> : <code>Object</code></dt>
<dd></dd>
<dt><a href="#CodeExtractItem">CodeExtractItem</a> : <code>Object</code></dt>
<dd></dd>
<dt><a href="#MetadataType">MetadataType</a> : <code>require(&#x27;../metadataTypes/MetadataType.js&#x27;)</code></dt>
<dd></dd>
<dt><a href="#BuObject">BuObject</a> : <code>Object</code></dt>
<dd></dd>
<dt><a href="#AuthObject">AuthObject</a> : <code>Object</code></dt>
<dd></dd>
<dt><a href="#MetadataType">MetadataType</a> : <code>require(&#x27;../metadataTypes/MetadataType.js&#x27;)</code></dt>
<dd></dd>
<dt><a href="#MultiMetadataTypeList">MultiMetadataTypeList</a> : <code>Object.&lt;string, string&gt;</code></dt>
<dd></dd>
</dl>

<a name="Builder"></a>

## Builder
Builds metadata from a template using market specific customisation

**Kind**: global class  

* [Builder](#Builder)
    * [new Builder(properties, buObject)](#new_Builder_new)
    * _instance_
        * [.buildDefinition(metadataType, name, variables)](#Builder+buildDefinition) ⇒ <code>Promise</code>
    * _static_
        * [.verifyMarketList(mlName, properties)](#Builder.verifyMarketList) ⇒ <code>void</code>

<a name="new_Builder_new"></a>

### new Builder(properties, buObject)
Creates a Builder


| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | properties for auth |
| properties.directories | <code>Object</code> | list of default directories |
| properties.directories.template | <code>String</code> | where templates are saved |
| properties.directories.templateBuilds | <code>String</code> | where template-based deployment definitions are saved |
| properties.businessUnits | <code>String</code> | ID of Business Unit to authenticate with |
| buObject | <code>auth.BuObject</code> | details of business unit in processing |

<a name="Builder+buildDefinition"></a>

### builder.buildDefinition(metadataType, name, variables) ⇒ <code>Promise</code>
Builds a specific metadata file by name

**Kind**: instance method of [<code>Builder</code>](#Builder)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataType | <code>String</code> | metadata type to build |
| name | <code>String</code> | name of metadata to build |
| variables | <code>Object</code> | variables to be replaced in the metadata |

<a name="Builder.verifyMarketList"></a>

### Builder.verifyMarketList(mlName, properties) ⇒ <code>void</code>
ensure provided MarketList exists and it's content including markets and BUs checks out

**Kind**: static method of [<code>Builder</code>](#Builder)  
**Returns**: <code>void</code> - throws errors if problems were found  

| Param | Type | Description |
| --- | --- | --- |
| mlName | <code>String</code> | name of marketList |
| properties | <code>Object</code> | General configuration to be used in retrieve |
| properties.markets | <code>Object</code> | list of template variable combos |
| properties.marketList | <code>Object</code> | list of bu-market combos |
| properties.credentials | <code>Object</code> | list of credentials and their BUs |

<a name="Deployer"></a>

## Deployer
Reads metadata from local directory and deploys it to specified target business unit.
Source and target business units are also compared before the deployment to apply metadata specific patches.

**Kind**: global class  

* [Deployer](#Deployer)
    * [new Deployer(properties, buObject, [type])](#new_Deployer_new)
    * _instance_
        * [.deploy()](#Deployer+deploy) ⇒ <code>Promise</code>
        * [.deployCallback(result, metadataType)](#Deployer+deployCallback) ⇒ <code>void</code>
    * _static_
        * [.readBUMetadata(deployDir, [type], [listBadKeys])](#Deployer.readBUMetadata) ⇒ <code>Object</code>
        * [.createFolderDefinitions(deployDir, metadata, metadataTypeArr)](#Deployer.createFolderDefinitions) ⇒ <code>void</code>

<a name="new_Deployer_new"></a>

### new Deployer(properties, buObject, [type])
Creates a Deployer, uses v2 auth if v2AuthOptions are passed.


| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | General configuration to be used in retrieve |
| properties.directories | <code>Object</code> | Directories to be used when interacting with FS |
| buObject | <code>auth.BuObject</code> | details of business unit in processing |
| [type] | <code>String</code> | limit deployment to given metadata type |

<a name="Deployer+deploy"></a>

### deployer.deploy() ⇒ <code>Promise</code>
Deploy all metadata that is located in the deployDir

**Kind**: instance method of [<code>Deployer</code>](#Deployer)  
**Returns**: <code>Promise</code> - Promise  
<a name="Deployer+deployCallback"></a>

### deployer.deployCallback(result, metadataType) ⇒ <code>void</code>
Gets called for every deployed metadata entry

**Kind**: instance method of [<code>Deployer</code>](#Deployer)  

| Param | Type | Description |
| --- | --- | --- |
| result | <code>Object</code> | Deployment result |
| metadataType | <code>String</code> | Name of metadata type |

<a name="Deployer.readBUMetadata"></a>

### Deployer.readBUMetadata(deployDir, [type], [listBadKeys]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: static method of [<code>Deployer</code>](#Deployer)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| deployDir | <code>String</code> |  | root directory of metadata. |
| [type] | <code>String</code> |  | limit deployment to given metadata type |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="Deployer.createFolderDefinitions"></a>

### Deployer.createFolderDefinitions(deployDir, metadata, metadataTypeArr) ⇒ <code>void</code>
parses asset metadata to auto-create folders in target folder

**Kind**: static method of [<code>Deployer</code>](#Deployer)  

| Param | Type | Description |
| --- | --- | --- |
| deployDir | <code>String</code> | root directory of metadata. |
| metadata | <code>Object</code> | list of metadata |
| metadataTypeArr | <code>String</code> | list of metadata types |

<a name="Mcdev"></a>

## Mcdev
main class

**Kind**: global class  

* [Mcdev](#Mcdev)
    * [.setSkipInteraction([skipInteraction])](#Mcdev.setSkipInteraction) ⇒ <code>void</code>
    * [.createDeltaPkg(argv)](#Mcdev.createDeltaPkg) ⇒ <code>void</code>
    * [.selectTypes()](#Mcdev.selectTypes) ⇒ <code>Promise</code>
    * [.explainTypes()](#Mcdev.explainTypes) ⇒ <code>Promise</code>
    * [.upgrade([skipInteraction])](#Mcdev.upgrade) ⇒ <code>Promise</code>
    * [.retrieve(businessUnit, [selectedType], [changelogOnly])](#Mcdev.retrieve) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [._retrieveBU(cred, bu, [selectedType], [changelogOnly])](#Mcdev._retrieveBU) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [._deployBU(cred, bu, [type])](#Mcdev._deployBU) ⇒ <code>Promise</code>
    * [.deploy(businessUnit, [selectedType])](#Mcdev.deploy) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.initProject([credentialsName], [skipInteraction])](#Mcdev.initProject) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findBUs(credentialsName)](#Mcdev.findBUs) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.document(businessUnit, type)](#Mcdev.document) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.deleteByKey(businessUnit, type, customerKey)](#Mcdev.deleteByKey) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.badKeys(businessUnit)](#Mcdev.badKeys) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.retrieveAsTemplate(businessUnit, selectedType, name, market)](#Mcdev.retrieveAsTemplate) ⇒ <code>Promise.&lt;Util.MultiMetadataTypeList&gt;</code>
    * [.buildDefinition(businessUnit, type, name, market)](#Mcdev.buildDefinition) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._checkMarket(market)](#Mcdev._checkMarket) ⇒ <code>Boolean</code>
    * [.buildDefinitionBulk(listName, type, name)](#Mcdev.buildDefinitionBulk) ⇒ <code>Promise.&lt;void&gt;</code>

<a name="Mcdev.setSkipInteraction"></a>

### Mcdev.setSkipInteraction([skipInteraction]) ⇒ <code>void</code>
helper method to use unattended mode when including mcdev as a package

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>boolean</code> \| <code>Object</code> | signals what to insert automatically for things usually asked via wizard |
| skipInteraction.clientId | <code>String</code> | client id of installed package |
| skipInteraction.clientSecret | <code>String</code> | client secret of installed package |
| skipInteraction.tenant | <code>String</code> | tenant of installed package |
| skipInteraction.eid | <code>String</code> | MID of the Parent Business Unit |
| skipInteraction.credentialsName | <code>String</code> | how you would like the credential to be named |

<a name="Mcdev.createDeltaPkg"></a>

### Mcdev.createDeltaPkg(argv) ⇒ <code>void</code>
handler for 'mcdev createDeltaPkg

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  

| Param | Type | Description |
| --- | --- | --- |
| argv | <code>Object</code> | yargs parameters |
| [argv.range] | <code>String</code> | git commit range     into deploy directory |
| [argv.filter] | <code>String</code> | filter file paths that start with any |
| [argv.skipInteraction] | <code>Boolean</code> | allows to skip interactive wizard |

<a name="Mcdev.selectTypes"></a>

### Mcdev.selectTypes() ⇒ <code>Promise</code>
**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise</code> - .  
<a name="Mcdev.explainTypes"></a>

### Mcdev.explainTypes() ⇒ <code>Promise</code>
**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise</code> - .  
<a name="Mcdev.upgrade"></a>

### Mcdev.upgrade([skipInteraction]) ⇒ <code>Promise</code>
**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise</code> - .  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Boolean</code> \| <code>Object</code> | signals what to insert automatically for things usually asked via wizard |

<a name="Mcdev.retrieve"></a>

### Mcdev.retrieve(businessUnit, [selectedType], [changelogOnly]) ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieve all metadata from the specified business unit into the local file system.

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>String</code> | references credentials from properties.json |
| [selectedType] | <code>String</code> | limit retrieval to given metadata type |
| [changelogOnly] | <code>boolean</code> | skip saving, only create json in memory |

<a name="Mcdev._retrieveBU"></a>

### Mcdev.\_retrieveBU(cred, bu, [selectedType], [changelogOnly]) ⇒ <code>Promise.&lt;Object&gt;</code>
helper for retrieve()

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - ensure that BUs are worked on sequentially  

| Param | Type | Description |
| --- | --- | --- |
| cred | <code>String</code> | name of Credential |
| bu | <code>String</code> | name of BU |
| [selectedType] | <code>String</code> | limit retrieval to given metadata type/subtype |
| [changelogOnly] | <code>boolean</code> | skip saving, only create json in memory |

<a name="Mcdev._deployBU"></a>

### Mcdev.\_deployBU(cred, bu, [type]) ⇒ <code>Promise</code>
helper for deploy()

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise</code> - ensure that BUs are worked on sequentially  

| Param | Type | Description |
| --- | --- | --- |
| cred | <code>String</code> | name of Credential |
| bu | <code>String</code> | name of BU |
| [type] | <code>String</code> | limit deployment to given metadata type |

<a name="Mcdev.deploy"></a>

### Mcdev.deploy(businessUnit, [selectedType]) ⇒ <code>Promise.&lt;void&gt;</code>
Deploys all metadata located in the 'deploy' directory to the specified business unit

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>String</code> | references credentials from properties.json |
| [selectedType] | <code>String</code> | limit deployment to given metadata type |

<a name="Mcdev.initProject"></a>

### Mcdev.initProject([credentialsName], [skipInteraction]) ⇒ <code>Promise.&lt;void&gt;</code>
Creates template file for properties.json

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| [credentialsName] | <code>string</code> | identifying name of the installed package / project |
| [skipInteraction] | <code>Boolean</code> \| <code>Object</code> | signals what to insert automatically for things usually asked via wizard |

<a name="Mcdev.findBUs"></a>

### Mcdev.findBUs(credentialsName) ⇒ <code>Promise.&lt;void&gt;</code>
Refreshes BU names and ID's from MC instance

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| credentialsName | <code>string</code> | identifying name of the installed package / project |

<a name="Mcdev.document"></a>

### Mcdev.document(businessUnit, type) ⇒ <code>Promise.&lt;void&gt;</code>
Creates docs for supported metadata types in Markdown and/or HTML format

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>String</code> | references credentials from properties.json |
| type | <code>String</code> | metadata type |

<a name="Mcdev.deleteByKey"></a>

### Mcdev.deleteByKey(businessUnit, type, customerKey) ⇒ <code>Promise.&lt;void&gt;</code>
Creates docs for supported metadata types in Markdown and/or HTML format

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>String</code> | references credentials from properties.json |
| type | <code>String</code> | supported metadata type |
| customerKey | <code>String</code> | Identifier of data extension |

<a name="Mcdev.badKeys"></a>

### Mcdev.badKeys(businessUnit) ⇒ <code>Promise.&lt;void&gt;</code>
Converts metadata to legacy format. Output is saved in 'converted' directory

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>String</code> | references credentials from properties.json |

<a name="Mcdev.retrieveAsTemplate"></a>

### Mcdev.retrieveAsTemplate(businessUnit, selectedType, name, market) ⇒ <code>Promise.&lt;Util.MultiMetadataTypeList&gt;</code>
Retrieve a specific metadata file and templatise.

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;Util.MultiMetadataTypeList&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>String</code> | references credentials from properties.json |
| selectedType | <code>String</code> | supported metadata type |
| name | <code>String</code> | name of the metadata |
| market | <code>String</code> | market which should be used to revert template |

<a name="Mcdev.buildDefinition"></a>

### Mcdev.buildDefinition(businessUnit, type, name, market) ⇒ <code>Promise.&lt;void&gt;</code>
Build a specific metadata file based on a template.

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| businessUnit | <code>String</code> | references credentials from properties.json |
| type | <code>String</code> | supported metadata type |
| name | <code>String</code> | name of the metadata |
| market | <code>String</code> | market localizations |

<a name="Mcdev._checkMarket"></a>

### Mcdev.\_checkMarket(market) ⇒ <code>Boolean</code>
check if a market name exists in current mcdev config

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Boolean</code> - found market or not  

| Param | Type | Description |
| --- | --- | --- |
| market | <code>String</code> | market localizations |

<a name="Mcdev.buildDefinitionBulk"></a>

### Mcdev.buildDefinitionBulk(listName, type, name) ⇒ <code>Promise.&lt;void&gt;</code>
Build a specific metadata file based on a template using a list of bu-market combos

**Kind**: static method of [<code>Mcdev</code>](#Mcdev)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| listName | <code>String</code> | name of list of BU-market combos |
| type | <code>String</code> | supported metadata type |
| name | <code>String</code> | name of the metadata |

<a name="AccountUser"></a>

## AccountUser ⇐ [<code>MetadataType</code>](#MetadataType)
MessageSendActivity MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [AccountUser](#AccountUser) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#AccountUser+retrieve) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.timeSinceDate(date, date2)](#AccountUser+timeSinceDate) ⇒ <code>number</code>
    * [.getBuName(id)](#AccountUser+getBuName) ⇒ <code>string</code>
    * [.document([metadata])](#AccountUser+document) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._generateDocMd(users, type, columnsToPrint)](#AccountUser+_generateDocMd) ⇒ <code>string</code>
    * [.postRetrieveTasks(metadata)](#AccountUser+postRetrieveTasks) ⇒ <code>Array.&lt;Object&gt;</code>
    * [.parseMetadata(metadata)](#AccountUser+parseMetadata) ⇒ <code>Array</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveForCache([subType])](#MetadataType+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
    * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
    * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="AccountUser+retrieve"></a>

### accountUser.retrieve(retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves SOAP based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="AccountUser+timeSinceDate"></a>

### accountUser.timeSinceDate(date, date2) ⇒ <code>number</code>
**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>number</code> - time difference  

| Param | Type | Description |
| --- | --- | --- |
| date | <code>string</code> | first date |
| date2 | <code>string</code> | second date |

<a name="AccountUser+getBuName"></a>

### accountUser.getBuName(id) ⇒ <code>string</code>
helper to print bu names

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>string</code> - "bu name (bu id)""  

| Param | Type | Description |
| --- | --- | --- |
| buObject.eid | <code>string</code> | needed to check for parent bu |
| id | <code>numeric</code> | bu id |

<a name="AccountUser+document"></a>

### accountUser.document([metadata]) ⇒ <code>Promise.&lt;void&gt;</code>
Creates markdown documentation of all roles

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Overrides**: [<code>document</code>](#MetadataType+document)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Object</code> | user list |

<a name="AccountUser+_generateDocMd"></a>

### accountUser.\_generateDocMd(users, type, columnsToPrint) ⇒ <code>string</code>
**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>string</code> - markdown  

| Param | Type | Description |
| --- | --- | --- |
| users | <code>Array.&lt;Object&gt;</code> | list of users and installed package |
| type | <code>&#x27;Installed Package&#x27;</code> \| <code>&#x27;User&#x27;</code> | choose what sub type to print |
| columnsToPrint | <code>Array.&lt;Array&gt;</code> | helper array |

<a name="AccountUser+postRetrieveTasks"></a>

### accountUser.postRetrieveTasks(metadata) ⇒ <code>Array.&lt;Object&gt;</code>
manages post retrieve steps

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Overrides**: [<code>postRetrieveTasks</code>](#MetadataType+postRetrieveTasks)  
**Returns**: <code>Array.&lt;Object&gt;</code> - Array with one metadata object and one query string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single query |

<a name="AccountUser+parseMetadata"></a>

### accountUser.parseMetadata(metadata) ⇒ <code>Array</code>
parses retrieved Metadata before saving

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Array</code> - Array with one metadata object and one sql string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single query activity definition |

<a name="MetadataType+getJsonFromFS"></a>

### accountUser.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### accountUser.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### accountUser.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### accountUser.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+overrideKeyWithName"></a>

### accountUser.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### accountUser.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveForCache"></a>

### accountUser.retrieveForCache([subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### accountUser.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### accountUser.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### accountUser.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### accountUser.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### accountUser.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### accountUser.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### accountUser.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### accountUser.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### accountUser.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### accountUser.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### accountUser.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### accountUser.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### accountUser.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### accountUser.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### accountUser.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### accountUser.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### accountUser.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### accountUser.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### accountUser.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### accountUser.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### accountUser.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### accountUser.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### accountUser.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### accountUser.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### accountUser.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+deleteByKey"></a>

### accountUser.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### accountUser.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### accountUser.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### accountUser.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>AccountUser</code>](#AccountUser)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="Asset"></a>

## Asset ⇐ [<code>MetadataType</code>](#MetadataType)
FileTransfer MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Asset](#Asset) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, _, __, [selectedSubType])](#Asset+retrieve) ⇒ <code>Promise.&lt;{metadata:AssetMap, type:string}&gt;</code>
    * [.retrieveForCache([selectedSubType])](#Asset+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:AssetMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [selectedSubType])](#Asset+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:AssetMap, type:string}&gt;</code>
    * [.create(metadata)](#Asset+create) ⇒ <code>Promise</code>
    * [.update(metadata)](#Asset+update) ⇒ <code>Promise</code>
    * [.requestSubType(subType, subTypeArray, [retrieveDir], [templateName], [templateVariables])](#Asset+requestSubType) ⇒ <code>Promise</code>
    * [.requestAndSaveExtended(items, subType, retrieveDir, [templateVariables])](#Asset+requestAndSaveExtended) ⇒ <code>Promise</code>
    * [._retrieveExtendedFile(metadata, subType, retrieveDir)](#Asset+_retrieveExtendedFile) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._readExtendedFileFromFS(metadata, subType, deployDir)](#Asset+_readExtendedFileFromFS) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.postRetrieveTasks(metadata, [_], isTemplating)](#Asset+postRetrieveTasks) ⇒ [<code>CodeExtractItem</code>](#CodeExtractItem)
    * [.preDeployTasks(metadata, deployDir)](#Asset+preDeployTasks) ⇒ <code>Promise.&lt;AssetItem&gt;</code>
    * [.getSubtype(metadata)](#Asset+getSubtype) ⇒ <code>AssetSubType</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#Asset+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.parseMetadata(metadata)](#Asset+parseMetadata) ⇒ [<code>CodeExtractItem</code>](#CodeExtractItem)
    * [._mergeCode(metadata, deployDir, subType, [templateName])](#Asset+_mergeCode) ⇒ <code>Promise.&lt;Array.&lt;MetadataType.CodeExtract&gt;&gt;</code>
    * [._mergeCode_slots(prefix, metadataSlots, readDirArr, subtypeExtension, subDirArr, fileList, customerKey, [templateName])](#Asset+_mergeCode_slots) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._extractCode(metadata)](#Asset+_extractCode) ⇒ [<code>CodeExtractItem</code>](#CodeExtractItem)
    * [._extractCode_slots(prefix, metadataSlots, codeArr)](#Asset+_extractCode_slots) ⇒ <code>void</code>
    * [.getJsonFromFS(dir)](#Asset+getJsonFromFS) ⇒ <code>Object</code>
    * [.findSubType(templateDir, templateName)](#Asset+findSubType) ⇒ <code>AssetSubType</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName)](#Asset+readSecondaryFolder) ⇒ <code>AssetItem</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="Asset+retrieve"></a>

### asset.retrieve(retrieveDir, _, __, [selectedSubType]) ⇒ <code>Promise.&lt;{metadata:AssetMap, type:string}&gt;</code>
Retrieves Metadata of Asset

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;{metadata:AssetMap, type:string}&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| _ | <code>void</code> | - |
| __ | <code>void</code> | - |
| [selectedSubType] | <code>AssetSubType</code> | optionally limit to a single subtype |

<a name="Asset+retrieveForCache"></a>

### asset.retrieveForCache([selectedSubType]) ⇒ <code>Promise.&lt;{metadata:AssetMap, type:string}&gt;</code>
Retrieves asset metadata for caching

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise.&lt;{metadata:AssetMap, type:string}&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| [selectedSubType] | <code>string</code> | optionally limit to a single subtype |

<a name="Asset+retrieveAsTemplate"></a>

### asset.retrieveAsTemplate(templateDir, name, templateVariables, [selectedSubType]) ⇒ <code>Promise.&lt;{metadata:AssetMap, type:string}&gt;</code>
Retrieves asset metadata for caching

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Overrides**: [<code>retrieveAsTemplate</code>](#MetadataType+retrieveAsTemplate)  
**Returns**: <code>Promise.&lt;{metadata:AssetMap, type:string}&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [selectedSubType] | <code>AssetSubType</code> | optionally limit to a single subtype |

<a name="Asset+create"></a>

### asset.create(metadata) ⇒ <code>Promise</code>
Creates a single asset

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Overrides**: [<code>create</code>](#MetadataType+create)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>AssetItem</code> | a single asset |

<a name="Asset+update"></a>

### asset.update(metadata) ⇒ <code>Promise</code>
Updates a single asset

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Overrides**: [<code>update</code>](#MetadataType+update)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>AssetItem</code> | a single asset |

<a name="Asset+requestSubType"></a>

### asset.requestSubType(subType, subTypeArray, [retrieveDir], [templateName], [templateVariables]) ⇒ <code>Promise</code>
Retrieves Metadata of a specific asset type

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| subType | <code>AssetSubType</code> | group of similar assets to put in a folder (ie. images) |
| subTypeArray | <code>Array.&lt;AssetSubType&gt;</code> | list of all asset types within this subtype |
| [retrieveDir] | <code>string</code> | target directory for saving assets |
| [templateName] | <code>string</code> | name of the metadata file |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="Asset+requestAndSaveExtended"></a>

### asset.requestAndSaveExtended(items, subType, retrieveDir, [templateVariables]) ⇒ <code>Promise</code>
Retrieves extended metadata (files or extended content) of asset

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| items | <code>Array</code> | array of items to retrieve |
| subType | <code>AssetSubType</code> | group of similar assets to put in a folder (ie. images) |
| retrieveDir | <code>string</code> | target directory for saving assets |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="Asset+_retrieveExtendedFile"></a>

### asset.\_retrieveExtendedFile(metadata, subType, retrieveDir) ⇒ <code>Promise.&lt;void&gt;</code>
Some metadata types store their actual content as a separate file, e.g. images
This method retrieves these and saves them alongside the metadata json

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>AssetItem</code> | a single asset |
| subType | <code>AssetSubType</code> | group of similar assets to put in a folder (ie. images) |
| retrieveDir | <code>string</code> | target directory for saving assets |

<a name="Asset+_readExtendedFileFromFS"></a>

### asset.\_readExtendedFileFromFS(metadata, subType, deployDir) ⇒ <code>Promise.&lt;void&gt;</code>
helper for this.preDeployTasks()
Some metadata types store their actual content as a separate file, e.g. images
This method reads these from the local FS stores them in the metadata object allowing to deploy it

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>AssetItem</code> | a single asset |
| subType | <code>AssetSubType</code> | group of similar assets to put in a folder (ie. images) |
| deployDir | <code>string</code> | directory of deploy files |

<a name="Asset+postRetrieveTasks"></a>

### asset.postRetrieveTasks(metadata, [_], isTemplating) ⇒ [<code>CodeExtractItem</code>](#CodeExtractItem)
manages post retrieve steps

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Overrides**: [<code>postRetrieveTasks</code>](#MetadataType+postRetrieveTasks)  
**Returns**: [<code>CodeExtractItem</code>](#CodeExtractItem) - metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>AssetItem</code> | a single asset |
| [_] | <code>string</code> | unused |
| isTemplating | <code>Boolean</code> | signals that we are retrieving templates |

<a name="Asset+preDeployTasks"></a>

### asset.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;AssetItem&gt;</code>
prepares an asset definition for deployment

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Overrides**: [<code>preDeployTasks</code>](#MetadataType+preDeployTasks)  
**Returns**: <code>Promise.&lt;AssetItem&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>AssetItem</code> | a single asset |
| deployDir | <code>string</code> | directory of deploy files |

<a name="Asset+getSubtype"></a>

### asset.getSubtype(metadata) ⇒ <code>AssetSubType</code>
determines the subtype of the current asset

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>AssetSubType</code> - subtype  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>AssetItem</code> | a single asset |

<a name="Asset+buildDefinitionForExtracts"></a>

### asset.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Overrides**: [<code>buildDefinitionForExtracts</code>](#MetadataType+buildDefinitionForExtracts)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>AssetItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="Asset+parseMetadata"></a>

### asset.parseMetadata(metadata) ⇒ [<code>CodeExtractItem</code>](#CodeExtractItem)
parses retrieved Metadata before saving

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: [<code>CodeExtractItem</code>](#CodeExtractItem) - parsed metadata definition  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>AssetItem</code> | a single asset definition |

<a name="Asset+_mergeCode"></a>

### asset.\_mergeCode(metadata, deployDir, subType, [templateName]) ⇒ <code>Promise.&lt;Array.&lt;MetadataType.CodeExtract&gt;&gt;</code>
helper for this.preDeployTasks() that loads extracted code content back into JSON

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;Array.&lt;MetadataType.CodeExtract&gt;&gt;</code> - fileList for templating (disregarded during deployment)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>AssetItem</code> | a single asset definition |
| deployDir | <code>string</code> | directory of deploy files |
| subType | <code>AssetSubType</code> | asset-subtype name |
| [templateName] | <code>string</code> | name of the template used to built defintion (prior applying templating) |

<a name="Asset+_mergeCode_slots"></a>

### asset.\_mergeCode\_slots(prefix, metadataSlots, readDirArr, subtypeExtension, subDirArr, fileList, customerKey, [templateName]) ⇒ <code>Promise.&lt;void&gt;</code>
helper for this.preDeployTasks() that loads extracted code content back into JSON

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| prefix | <code>string</code> | usually the customerkey |
| metadataSlots | <code>Object</code> | metadata.views.html.slots or deeper slots.<>.blocks.<>.slots |
| readDirArr | <code>Array.&lt;string&gt;</code> | directory of deploy files |
| subtypeExtension | <code>string</code> | asset-subtype name ending on -meta |
| subDirArr | <code>Array.&lt;string&gt;</code> | directory of files w/o leading deploy dir |
| fileList | <code>Array.&lt;Object&gt;</code> | directory of files w/o leading deploy dir |
| customerKey | <code>string</code> | external key of template (could have been changed if used during templating) |
| [templateName] | <code>string</code> | name of the template used to built defintion (prior applying templating) |

<a name="Asset+_extractCode"></a>

### asset.\_extractCode(metadata) ⇒ [<code>CodeExtractItem</code>](#CodeExtractItem)
helper for this.parseMetadata() that finds code content in JSON and extracts it
to allow saving that separately and formatted

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: [<code>CodeExtractItem</code>](#CodeExtractItem) - { json: metadata, codeArr: object[], subFolder: string[] }  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>AssetItem</code> | a single asset definition |

<a name="Asset+_extractCode_slots"></a>

### asset.\_extractCode\_slots(prefix, metadataSlots, codeArr) ⇒ <code>void</code>
**Kind**: instance method of [<code>Asset</code>](#Asset)  

| Param | Type | Description |
| --- | --- | --- |
| prefix | <code>string</code> | usually the customerkey |
| metadataSlots | <code>Object</code> | metadata.views.html.slots or deeper slots.<>.blocks.<>.slots |
| codeArr | <code>Array.&lt;Object&gt;</code> | to be extended array for extracted code |

<a name="Asset+getJsonFromFS"></a>

### asset.getJsonFromFS(dir) ⇒ <code>Object</code>
Returns file contents mapped to their fileName without '.json' ending

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Overrides**: [<code>getJsonFromFS</code>](#MetadataType+getJsonFromFS)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Description |
| --- | --- | --- |
| dir | <code>string</code> | directory that contains '.json' files to be read |

<a name="Asset+findSubType"></a>

### asset.findSubType(templateDir, templateName) ⇒ <code>AssetSubType</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Overrides**: [<code>findSubType</code>](#MetadataType+findSubType)  
**Returns**: <code>AssetSubType</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="Asset+readSecondaryFolder"></a>

### asset.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName) ⇒ <code>AssetItem</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Overrides**: [<code>readSecondaryFolder</code>](#MetadataType+readSecondaryFolder)  
**Returns**: <code>AssetItem</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### asset.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### asset.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### asset.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>Asset</code>](#Asset)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+overrideKeyWithName"></a>

### asset.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>Asset</code>](#Asset)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### asset.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+upsert"></a>

### asset.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### asset.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### asset.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### asset.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### asset.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### asset.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### asset.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### asset.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### asset.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>Asset</code>](#Asset)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### asset.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>Asset</code>](#Asset)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### asset.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>Asset</code>](#Asset)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### asset.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>Asset</code>](#Asset)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### asset.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>Asset</code>](#Asset)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### asset.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### asset.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### asset.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinition"></a>

### asset.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### asset.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### asset.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Asset</code>](#Asset)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### asset.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### asset.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### asset.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### asset.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>Asset</code>](#Asset)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="AttributeGroup"></a>

## AttributeGroup ⇐ [<code>MetadataType</code>](#MetadataType)
AttributeGroup MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [AttributeGroup](#AttributeGroup) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieveForCache()](#AttributeGroup+retrieveForCache) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.retrieve(retrieveDir)](#AttributeGroup+retrieve) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.postRetrieveTasks(metadata, targetDir, [isTemplating])](#MetadataType+postRetrieveTasks) ⇒ <code>Util.MetadataTypeItem</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
    * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
    * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="AttributeGroup+retrieveForCache"></a>

### attributeGroup.retrieveForCache() ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves Metadata of schema attribute groups for caching.

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  
<a name="AttributeGroup+retrieve"></a>

### attributeGroup.retrieve(retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves Metadata of schema attribute groups.

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="MetadataType+getJsonFromFS"></a>

### attributeGroup.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### attributeGroup.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### attributeGroup.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### attributeGroup.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+postRetrieveTasks"></a>

### attributeGroup.postRetrieveTasks(metadata, targetDir, [isTemplating]) ⇒ <code>Util.MetadataTypeItem</code>
Gets executed after retreive of metadata type

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Util.MetadataTypeItem</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| targetDir | <code>string</code> | folder where retrieves should be saved |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="MetadataType+overrideKeyWithName"></a>

### attributeGroup.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### attributeGroup.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### attributeGroup.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### attributeGroup.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### attributeGroup.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### attributeGroup.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### attributeGroup.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### attributeGroup.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### attributeGroup.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### attributeGroup.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### attributeGroup.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### attributeGroup.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### attributeGroup.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### attributeGroup.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### attributeGroup.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### attributeGroup.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### attributeGroup.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### attributeGroup.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### attributeGroup.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### attributeGroup.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### attributeGroup.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### attributeGroup.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### attributeGroup.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### attributeGroup.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### attributeGroup.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### attributeGroup.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### attributeGroup.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### attributeGroup.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### attributeGroup.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### attributeGroup.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### attributeGroup.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### attributeGroup.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>AttributeGroup</code>](#AttributeGroup)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="Automation"></a>

## Automation ⇐ [<code>MetadataType</code>](#MetadataType)
Automation MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Automation](#Automation) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#Automation+retrieve) ⇒ <code>Promise.&lt;{metadata:AutomationMap, type:string}&gt;</code>
    * [.retrieveChangelog()](#Automation+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:AutomationMap, type:string}&gt;</code>
    * [.retrieveForCache()](#Automation+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:AutomationMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables)](#Automation+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:AutomationMap, type:string}&gt;</code>
    * [.postRetrieveTasks(metadata, [_], [isTemplating])](#Automation+postRetrieveTasks) ⇒ <code>AutomationItem</code>
    * [.deploy(metadata, targetBU, retrieveDir)](#Automation+deploy) ⇒ [<code>Promise.&lt;AutomationMap&gt;</code>](#AutomationMap)
    * [.create(metadata)](#Automation+create) ⇒ <code>Promise</code>
    * [.update(metadata, metadataBefore)](#Automation+update) ⇒ <code>Promise</code>
    * [.preDeployTasks(metadata)](#Automation+preDeployTasks) ⇒ <code>Promise.&lt;AutomationItem&gt;</code>
    * [.validateDeployMetadata(metadata)](#Automation+validateDeployMetadata) ⇒ <code>Boolean</code>
    * [.postDeployTasks(metadata, originalMetadata)](#Automation+postDeployTasks) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.parseMetadata(metadata)](#Automation+parseMetadata) ⇒ <code>Array</code>
    * [._buildSchedule(scheduleObject)](#Automation+_buildSchedule) ⇒ <code>AutomationScheduleSoap</code>
    * [._calcTime(offsetServer, dateInput, [offsetInput])](#Automation+_calcTime) ⇒ <code>string</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="Automation+retrieve"></a>

### automation.retrieve(retrieveDir) ⇒ <code>Promise.&lt;{metadata:AutomationMap, type:string}&gt;</code>
Retrieves Metadata of Automation

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;{metadata:AutomationMap, type:string}&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |

<a name="Automation+retrieveChangelog"></a>

### automation.retrieveChangelog() ⇒ <code>Promise.&lt;{metadata:AutomationMap, type:string}&gt;</code>
Retrieves Metadata of Automation

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Overrides**: [<code>retrieveChangelog</code>](#MetadataType+retrieveChangelog)  
**Returns**: <code>Promise.&lt;{metadata:AutomationMap, type:string}&gt;</code> - Promise of metadata  
<a name="Automation+retrieveForCache"></a>

### automation.retrieveForCache() ⇒ <code>Promise.&lt;{metadata:AutomationMap, type:string}&gt;</code>
Retrieves automation metadata for caching

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise.&lt;{metadata:AutomationMap, type:string}&gt;</code> - Promise of metadata  
<a name="Automation+retrieveAsTemplate"></a>

### automation.retrieveAsTemplate(templateDir, name, templateVariables) ⇒ <code>Promise.&lt;{metadata:AutomationMap, type:string}&gt;</code>
Retrieve a specific Automation Definition by Name

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Overrides**: [<code>retrieveAsTemplate</code>](#MetadataType+retrieveAsTemplate)  
**Returns**: <code>Promise.&lt;{metadata:AutomationMap, type:string}&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="Automation+postRetrieveTasks"></a>

### automation.postRetrieveTasks(metadata, [_], [isTemplating]) ⇒ <code>AutomationItem</code>
manages post retrieve steps

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Overrides**: [<code>postRetrieveTasks</code>](#MetadataType+postRetrieveTasks)  
**Returns**: <code>AutomationItem</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>AutomationItem</code> | a single automation |
| [_] | <code>string</code> | unused |
| [isTemplating] | <code>Boolean</code> | signals that we are retrieving templates |

<a name="Automation+deploy"></a>

### automation.deploy(metadata, targetBU, retrieveDir) ⇒ [<code>Promise.&lt;AutomationMap&gt;</code>](#AutomationMap)
Deploys automation - the saved file is the original one due to large differences required for deployment

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Overrides**: [<code>deploy</code>](#MetadataType+deploy)  
**Returns**: [<code>Promise.&lt;AutomationMap&gt;</code>](#AutomationMap) - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | [<code>AutomationMap</code>](#AutomationMap) | metadata mapped by their keyField |
| targetBU | <code>string</code> | name/shorthand of target businessUnit for mapping |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="Automation+create"></a>

### automation.create(metadata) ⇒ <code>Promise</code>
Creates a single automation

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Overrides**: [<code>create</code>](#MetadataType+create)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>AutomationItem</code> | single metadata entry |

<a name="Automation+update"></a>

### automation.update(metadata, metadataBefore) ⇒ <code>Promise</code>
Updates a single automation

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Overrides**: [<code>update</code>](#MetadataType+update)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>AutomationItem</code> | single metadata entry |
| metadataBefore | <code>AutomationItem</code> | metadata mapped by their keyField |

<a name="Automation+preDeployTasks"></a>

### automation.preDeployTasks(metadata) ⇒ <code>Promise.&lt;AutomationItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Overrides**: [<code>preDeployTasks</code>](#MetadataType+preDeployTasks)  
**Returns**: <code>Promise.&lt;AutomationItem&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>AutomationItem</code> | metadata mapped by their keyField |

<a name="Automation+validateDeployMetadata"></a>

### automation.validateDeployMetadata(metadata) ⇒ <code>Boolean</code>
Validates the automation to be sure it can be deployed.
Whitelisted Activites are deployed but require configuration

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Boolean</code> - result if automation can be deployed based on steps  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>AutomationItem</code> | single automation record |

<a name="Automation+postDeployTasks"></a>

### automation.postDeployTasks(metadata, originalMetadata) ⇒ <code>Promise.&lt;void&gt;</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Overrides**: [<code>postDeployTasks</code>](#MetadataType+postDeployTasks)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| metadata | [<code>AutomationMap</code>](#AutomationMap) | metadata mapped by their keyField |
| originalMetadata | [<code>AutomationMap</code>](#AutomationMap) | metadata to be updated (contains additioanl fields) |

<a name="Automation+parseMetadata"></a>

### automation.parseMetadata(metadata) ⇒ <code>Array</code>
parses retrieved Metadata before saving

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Array</code> - Array with one metadata object and one sql string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>AutomationItem</code> | a single automation definition |

<a name="Automation+_buildSchedule"></a>

### automation.\_buildSchedule(scheduleObject) ⇒ <code>AutomationScheduleSoap</code>
Builds a schedule object to be used for scheduling an automation
based on combination of ical string and start/end dates.

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>AutomationScheduleSoap</code> - Schedulable object for soap API (currently not rest supported)  

| Param | Type | Description |
| --- | --- | --- |
| scheduleObject | <code>AutomationSchedule</code> | child of automation metadata used for scheduling |

<a name="Automation+_calcTime"></a>

### automation.\_calcTime(offsetServer, dateInput, [offsetInput]) ⇒ <code>string</code>
used to convert dates to the system timezone required for startDate

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>string</code> - date in server  

| Param | Type | Description |
| --- | --- | --- |
| offsetServer | <code>number</code> | stack4: US Mountain time (UTC-7); other stacks: US Central (UTC-6) |
| dateInput | <code>string</code> \| <code>Date</code> | date in ISO format (2021-12-05T20:00:00.983) |
| [offsetInput] | <code>string</code> | timzone difference (+02:00) |

<a name="MetadataType+getJsonFromFS"></a>

### automation.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### automation.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+overrideKeyWithName"></a>

### automation.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>Automation</code>](#Automation)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+upsert"></a>

### automation.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### automation.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### automation.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### automation.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### automation.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### automation.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### automation.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### automation.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### automation.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>Automation</code>](#Automation)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### automation.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>Automation</code>](#Automation)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### automation.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>Automation</code>](#Automation)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### automation.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>Automation</code>](#Automation)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### automation.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>Automation</code>](#Automation)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### automation.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### automation.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### automation.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### automation.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### automation.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### automation.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### automation.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### automation.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### automation.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Automation</code>](#Automation)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### automation.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### automation.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### automation.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### automation.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>Automation</code>](#Automation)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="Campaign"></a>

## Campaign ⇐ [<code>MetadataType</code>](#MetadataType)
Campaign MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Campaign](#Campaign) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#Campaign+retrieve) ⇒ <code>Promise</code>
    * [.getAssetTags(retrieveDir, id, name)](#Campaign+getAssetTags) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.postRetrieveTasks(metadata, targetDir, [isTemplating])](#MetadataType+postRetrieveTasks) ⇒ <code>Util.MetadataTypeItem</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveForCache([subType])](#MetadataType+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
    * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
    * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="Campaign+retrieve"></a>

### campaign.retrieve(retrieveDir) ⇒ <code>Promise</code>
Retrieves Metadata of campaigns. Afterwards, starts metadata retrieval for their campaign assets

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="Campaign+getAssetTags"></a>

### campaign.getAssetTags(retrieveDir, id, name) ⇒ <code>Promise.&lt;Object&gt;</code>
Parses campaign asset response body and returns metadata entries mapped to their id

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Campaign Asset Object  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | folder where to save |
| id | <code>String</code> | of camapaign to retrieve |
| name | <code>String</code> | of camapaign for saving |

<a name="MetadataType+getJsonFromFS"></a>

### campaign.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### campaign.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### campaign.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### campaign.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+postRetrieveTasks"></a>

### campaign.postRetrieveTasks(metadata, targetDir, [isTemplating]) ⇒ <code>Util.MetadataTypeItem</code>
Gets executed after retreive of metadata type

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Util.MetadataTypeItem</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| targetDir | <code>string</code> | folder where retrieves should be saved |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="MetadataType+overrideKeyWithName"></a>

### campaign.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### campaign.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveForCache"></a>

### campaign.retrieveForCache([subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### campaign.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### campaign.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### campaign.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### campaign.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### campaign.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### campaign.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### campaign.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### campaign.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### campaign.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### campaign.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### campaign.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### campaign.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### campaign.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### campaign.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### campaign.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### campaign.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### campaign.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### campaign.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### campaign.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### campaign.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### campaign.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### campaign.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### campaign.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### campaign.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### campaign.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### campaign.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### campaign.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### campaign.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### campaign.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### campaign.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>Campaign</code>](#Campaign)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="ContentArea"></a>

## ContentArea ⇐ [<code>MetadataType</code>](#MetadataType)
ContentArea MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [ContentArea](#ContentArea) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#ContentArea+retrieve) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postRetrieveTasks(metadata)](#ContentArea+postRetrieveTasks) ⇒ <code>Array.&lt;Object&gt;</code>
    * [.parseMetadata(metadata)](#ContentArea+parseMetadata) ⇒ <code>Array</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveForCache([subType])](#MetadataType+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
    * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
    * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="ContentArea+retrieve"></a>

### contentArea.retrieve(retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves SOAP based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="ContentArea+postRetrieveTasks"></a>

### contentArea.postRetrieveTasks(metadata) ⇒ <code>Array.&lt;Object&gt;</code>
manages post retrieve steps

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Overrides**: [<code>postRetrieveTasks</code>](#MetadataType+postRetrieveTasks)  
**Returns**: <code>Array.&lt;Object&gt;</code> - Array with one metadata object and one query string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single query |

<a name="ContentArea+parseMetadata"></a>

### contentArea.parseMetadata(metadata) ⇒ <code>Array</code>
parses retrieved Metadata before saving

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Array</code> - Array with one metadata object and one sql string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single query activity definition |

<a name="MetadataType+getJsonFromFS"></a>

### contentArea.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### contentArea.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### contentArea.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### contentArea.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+overrideKeyWithName"></a>

### contentArea.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### contentArea.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveForCache"></a>

### contentArea.retrieveForCache([subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### contentArea.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### contentArea.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### contentArea.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### contentArea.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### contentArea.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### contentArea.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### contentArea.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### contentArea.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### contentArea.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### contentArea.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### contentArea.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### contentArea.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### contentArea.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### contentArea.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### contentArea.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### contentArea.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### contentArea.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### contentArea.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### contentArea.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### contentArea.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### contentArea.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### contentArea.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### contentArea.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### contentArea.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### contentArea.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### contentArea.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### contentArea.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### contentArea.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### contentArea.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### contentArea.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>ContentArea</code>](#ContentArea)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="DataExtension"></a>

## DataExtension ⇐ [<code>MetadataType</code>](#MetadataType)
DataExtension MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [DataExtension](#DataExtension) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.upsert(desToDeploy)](#DataExtension+upsert) ⇒ <code>Promise</code>
    * [._filterUpsertResults(res)](#DataExtension+_filterUpsertResults) ⇒ <code>Boolean</code>
    * [.create(metadata)](#DataExtension+create) ⇒ <code>Promise</code>
    * [.update(metadata)](#DataExtension+update) ⇒ <code>Promise</code>
    * [.postDeployTasks(upsertedMetadata)](#DataExtension+postDeployTasks) ⇒ <code>void</code>
    * [.retrieve(retrieveDir, [additionalFields], [_], [isDeploy])](#DataExtension+retrieve) ⇒ <code>Promise.&lt;{metadata:DataExtensionMap, type:string}&gt;</code>
    * [.retrieveChangelog([additionalFields])](#DataExtension+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:DataExtensionMap, type:string}&gt;</code>
    * [.postRetrieveTasks(metadata, [_], [isTemplating])](#DataExtension+postRetrieveTasks) ⇒ <code>DataExtensionItem</code>
    * [.preDeployTasks(metadata)](#DataExtension+preDeployTasks) ⇒ <code>Promise.&lt;DataExtensionItem&gt;</code>
    * [.document([metadata], [isDeploy])](#DataExtension+document) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.deleteByKey(customerKey)](#DataExtension+deleteByKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.postDeleteTasks(customerKey)](#DataExtension+postDeleteTasks) ⇒ <code>void</code>
    * [.retrieveForCache([_], [isDeploy])](#DataExtension+retrieveForCache) ⇒ <code>Promise</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables)](#DataExtension+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:DataExtensionMap, type:string}&gt;</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="DataExtension+upsert"></a>

### dataExtension.upsert(desToDeploy) ⇒ <code>Promise</code>
Upserts dataExtensions after retrieving them from source and target to compare
if create or update operation is needed.

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Overrides**: [<code>upsert</code>](#MetadataType+upsert)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| desToDeploy | [<code>DataExtensionMap</code>](#DataExtensionMap) | dataExtensions mapped by their customerKey |

<a name="DataExtension+_filterUpsertResults"></a>

### dataExtension.\_filterUpsertResults(res) ⇒ <code>Boolean</code>
helper for upsert()

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Boolean</code> - true: keep, false: discard  

| Param | Type | Description |
| --- | --- | --- |
| res | <code>Object</code> | - |

<a name="DataExtension+create"></a>

### dataExtension.create(metadata) ⇒ <code>Promise</code>
Create a single dataExtension. Also creates their columns in 'dataExtension.columns'

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Overrides**: [<code>create</code>](#MetadataType+create)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>DataExtensionItem</code> | single metadata entry |

<a name="DataExtension+update"></a>

### dataExtension.update(metadata) ⇒ <code>Promise</code>
Updates a single dataExtension. Also updates their columns in 'dataExtension.columns'

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Overrides**: [<code>update</code>](#MetadataType+update)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>DataExtensionItem</code> | single metadata entry |

<a name="DataExtension+postDeployTasks"></a>

### dataExtension.postDeployTasks(upsertedMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Overrides**: [<code>postDeployTasks</code>](#MetadataType+postDeployTasks)  

| Param | Type | Description |
| --- | --- | --- |
| upsertedMetadata | [<code>DataExtensionMap</code>](#DataExtensionMap) | metadata mapped by their keyField |

<a name="DataExtension+retrieve"></a>

### dataExtension.retrieve(retrieveDir, [additionalFields], [_], [isDeploy]) ⇒ <code>Promise.&lt;{metadata:DataExtensionMap, type:string}&gt;</code>
Retrieves dataExtension metadata. Afterwards starts retrieval of dataExtensionColumn metadata retrieval

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;{metadata:DataExtensionMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [_] | <code>void</code> | - |
| [isDeploy] | <code>boolean</code> | used to signal that fields shall be retrieve in caching mode |

<a name="DataExtension+retrieveChangelog"></a>

### dataExtension.retrieveChangelog([additionalFields]) ⇒ <code>Promise.&lt;{metadata:DataExtensionMap, type:string}&gt;</code>
Retrieves dataExtension metadata. Afterwards starts retrieval of dataExtensionColumn metadata retrieval

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Overrides**: [<code>retrieveChangelog</code>](#MetadataType+retrieveChangelog)  
**Returns**: <code>Promise.&lt;{metadata:DataExtensionMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="DataExtension+postRetrieveTasks"></a>

### dataExtension.postRetrieveTasks(metadata, [_], [isTemplating]) ⇒ <code>DataExtensionItem</code>
manages post retrieve steps

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Overrides**: [<code>postRetrieveTasks</code>](#MetadataType+postRetrieveTasks)  
**Returns**: <code>DataExtensionItem</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>DataExtensionItem</code> | a single dataExtension |
| [_] | <code>string</code> | unused |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="DataExtension+preDeployTasks"></a>

### dataExtension.preDeployTasks(metadata) ⇒ <code>Promise.&lt;DataExtensionItem&gt;</code>
prepares a DataExtension for deployment

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Overrides**: [<code>preDeployTasks</code>](#MetadataType+preDeployTasks)  
**Returns**: <code>Promise.&lt;DataExtensionItem&gt;</code> - Promise of updated single DE  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>DataExtensionItem</code> | a single data Extension |

<a name="DataExtension+document"></a>

### dataExtension.document([metadata], [isDeploy]) ⇒ <code>Promise.&lt;void&gt;</code>
Parses metadata into a readable Markdown/HTML format then saves it

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Overrides**: [<code>document</code>](#MetadataType+document)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | [<code>DataExtensionMap</code>](#DataExtensionMap) | a list of dataExtension definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="DataExtension+deleteByKey"></a>

### dataExtension.deleteByKey(customerKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Overrides**: [<code>deleteByKey</code>](#MetadataType+deleteByKey)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="DataExtension+postDeleteTasks"></a>

### dataExtension.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Overrides**: [<code>postDeleteTasks</code>](#MetadataType+postDeleteTasks)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="DataExtension+retrieveForCache"></a>

### dataExtension.retrieveForCache([_], [isDeploy]) ⇒ <code>Promise</code>
Retrieves folder metadata into local filesystem. Also creates a uniquePath attribute for each folder.

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| [_] | <code>void</code> | - |
| [isDeploy] | <code>boolean</code> | used to signal that fields shall be retrieve in caching mode |

<a name="DataExtension+retrieveAsTemplate"></a>

### dataExtension.retrieveAsTemplate(templateDir, name, templateVariables) ⇒ <code>Promise.&lt;{metadata:DataExtensionMap, type:string}&gt;</code>
Retrieves dataExtension metadata in template format.

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Overrides**: [<code>retrieveAsTemplate</code>](#MetadataType+retrieveAsTemplate)  
**Returns**: <code>Promise.&lt;{metadata:DataExtensionMap, type:string}&gt;</code> - Promise of items  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata item |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+getJsonFromFS"></a>

### dataExtension.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### dataExtension.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### dataExtension.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+overrideKeyWithName"></a>

### dataExtension.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+createREST"></a>

### dataExtension.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### dataExtension.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### dataExtension.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### dataExtension.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### dataExtension.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### dataExtension.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### dataExtension.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### dataExtension.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### dataExtension.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### dataExtension.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### dataExtension.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### dataExtension.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### dataExtension.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### dataExtension.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### dataExtension.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### dataExtension.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### dataExtension.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### dataExtension.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### dataExtension.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### dataExtension.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+deleteByKeySOAP"></a>

### dataExtension.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### dataExtension.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>DataExtension</code>](#DataExtension)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="DataExtensionField"></a>

## DataExtensionField ⇐ [<code>MetadataType</code>](#MetadataType)
DataExtensionField MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [DataExtensionField](#DataExtensionField) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [additionalFields])](#DataExtensionField+retrieve) ⇒ <code>Promise.&lt;{metadata:DataExtensionFieldMap, type:string}&gt;</code>
    * [.retrieveForCache([requestParams], [additionalFields])](#DataExtensionField+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:DataExtensionFieldMap, type:string}&gt;</code>
    * [.convertToSortedArray(fieldsObj)](#DataExtensionField+convertToSortedArray) ⇒ <code>Array.&lt;DataExtensionFieldItem&gt;</code>
    * [.sortDeFields(a, b)](#DataExtensionField+sortDeFields) ⇒ <code>boolean</code>
    * [.postRetrieveTasks(metadata, forDataExtension)](#DataExtensionField+postRetrieveTasks) ⇒ <code>DataExtensionFieldItem</code>
    * [.prepareDeployColumnsOnUpdate(deployColumns, deKey)](#DataExtensionField+prepareDeployColumnsOnUpdate) ⇒ <code>Object.&lt;string, DataExtensionFieldItem&gt;</code>
    * [.deleteByKey(customerKey)](#DataExtensionField+deleteByKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#DataExtensionField+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#DataExtensionField+postDeleteTasks) ⇒ <code>void</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
    * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
    * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="DataExtensionField+retrieve"></a>

### dataExtensionField.retrieve(retrieveDir, [additionalFields]) ⇒ <code>Promise.&lt;{metadata:DataExtensionFieldMap, type:string}&gt;</code>
Retrieves all records and saves it to disk

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;{metadata:DataExtensionFieldMap, type:string}&gt;</code> - Promise of items  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="DataExtensionField+retrieveForCache"></a>

### dataExtensionField.retrieveForCache([requestParams], [additionalFields]) ⇒ <code>Promise.&lt;{metadata:DataExtensionFieldMap, type:string}&gt;</code>
Retrieves all records for caching

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise.&lt;{metadata:DataExtensionFieldMap, type:string}&gt;</code> - Promise of items  

| Param | Type | Description |
| --- | --- | --- |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="DataExtensionField+convertToSortedArray"></a>

### dataExtensionField.convertToSortedArray(fieldsObj) ⇒ <code>Array.&lt;DataExtensionFieldItem&gt;</code>
helper for DataExtension.js that sorts the fields into an array

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Array.&lt;DataExtensionFieldItem&gt;</code> - sorted array of field objects  

| Param | Type | Description |
| --- | --- | --- |
| fieldsObj | [<code>DataExtensionFieldMap</code>](#DataExtensionFieldMap) | customerKey-based list of fields for one dataExtension |

<a name="DataExtensionField+sortDeFields"></a>

### dataExtensionField.sortDeFields(a, b) ⇒ <code>boolean</code>
sorting method to ensure `Ordinal` is respected

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>boolean</code> - sorting based on Ordinal  

| Param | Type | Description |
| --- | --- | --- |
| a | <code>DataExtensionFieldItem</code> | - |
| b | <code>DataExtensionFieldItem</code> | - |

<a name="DataExtensionField+postRetrieveTasks"></a>

### dataExtensionField.postRetrieveTasks(metadata, forDataExtension) ⇒ <code>DataExtensionFieldItem</code>
manages post retrieve steps

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Overrides**: [<code>postRetrieveTasks</code>](#MetadataType+postRetrieveTasks)  
**Returns**: <code>DataExtensionFieldItem</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>DataExtensionFieldItem</code> | a single item |
| forDataExtension | <code>boolean</code> | when used by DataExtension class we remove more fields |

<a name="DataExtensionField+prepareDeployColumnsOnUpdate"></a>

### dataExtensionField.prepareDeployColumnsOnUpdate(deployColumns, deKey) ⇒ <code>Object.&lt;string, DataExtensionFieldItem&gt;</code>
Mofifies passed deployColumns for update by mapping ObjectID to their target column's values.
Removes FieldType field if its the same in deploy and target column, because it results in an error even if its of the same type

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Object.&lt;string, DataExtensionFieldItem&gt;</code> - existing fields by their original name to allow re-adding FieldType after update  

| Param | Type | Description |
| --- | --- | --- |
| deployColumns | <code>Array.&lt;DataExtensionFieldItem&gt;</code> | Columns of data extension that will be deployed |
| deKey | <code>string</code> | external/customer key of Data Extension |

<a name="DataExtensionField+deleteByKey"></a>

### dataExtensionField.deleteByKey(customerKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Overrides**: [<code>deleteByKey</code>](#MetadataType+deleteByKey)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="DataExtensionField+deleteByKeySOAP"></a>

### dataExtensionField.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Overrides**: [<code>deleteByKeySOAP</code>](#MetadataType+deleteByKeySOAP)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="DataExtensionField+postDeleteTasks"></a>

### dataExtensionField.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Overrides**: [<code>postDeleteTasks</code>](#MetadataType+postDeleteTasks)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+getJsonFromFS"></a>

### dataExtensionField.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### dataExtensionField.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### dataExtensionField.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### dataExtensionField.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+overrideKeyWithName"></a>

### dataExtensionField.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### dataExtensionField.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### dataExtensionField.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### dataExtensionField.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### dataExtensionField.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### dataExtensionField.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### dataExtensionField.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### dataExtensionField.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### dataExtensionField.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### dataExtensionField.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### dataExtensionField.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### dataExtensionField.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### dataExtensionField.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### dataExtensionField.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### dataExtensionField.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### dataExtensionField.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### dataExtensionField.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### dataExtensionField.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### dataExtensionField.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### dataExtensionField.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### dataExtensionField.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### dataExtensionField.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### dataExtensionField.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### dataExtensionField.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### dataExtensionField.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### dataExtensionField.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### dataExtensionField.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### dataExtensionField.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+readBUMetadataForType"></a>

### dataExtensionField.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>DataExtensionField</code>](#DataExtensionField)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="DataExtensionTemplate"></a>

## DataExtensionTemplate ⇐ [<code>MetadataType</code>](#MetadataType)
DataExtensionTemplate MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [DataExtensionTemplate](#DataExtensionTemplate) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#DataExtensionTemplate+retrieve) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.postRetrieveTasks(metadata, targetDir, [isTemplating])](#MetadataType+postRetrieveTasks) ⇒ <code>Util.MetadataTypeItem</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveForCache([subType])](#MetadataType+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
    * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
    * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="DataExtensionTemplate+retrieve"></a>

### dataExtensionTemplate.retrieve(retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves SOAP based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="MetadataType+getJsonFromFS"></a>

### dataExtensionTemplate.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### dataExtensionTemplate.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### dataExtensionTemplate.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### dataExtensionTemplate.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+postRetrieveTasks"></a>

### dataExtensionTemplate.postRetrieveTasks(metadata, targetDir, [isTemplating]) ⇒ <code>Util.MetadataTypeItem</code>
Gets executed after retreive of metadata type

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Util.MetadataTypeItem</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| targetDir | <code>string</code> | folder where retrieves should be saved |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="MetadataType+overrideKeyWithName"></a>

### dataExtensionTemplate.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### dataExtensionTemplate.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveForCache"></a>

### dataExtensionTemplate.retrieveForCache([subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### dataExtensionTemplate.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### dataExtensionTemplate.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### dataExtensionTemplate.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### dataExtensionTemplate.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### dataExtensionTemplate.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### dataExtensionTemplate.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### dataExtensionTemplate.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### dataExtensionTemplate.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### dataExtensionTemplate.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### dataExtensionTemplate.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### dataExtensionTemplate.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### dataExtensionTemplate.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### dataExtensionTemplate.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### dataExtensionTemplate.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### dataExtensionTemplate.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### dataExtensionTemplate.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### dataExtensionTemplate.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### dataExtensionTemplate.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### dataExtensionTemplate.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### dataExtensionTemplate.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### dataExtensionTemplate.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### dataExtensionTemplate.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### dataExtensionTemplate.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### dataExtensionTemplate.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### dataExtensionTemplate.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### dataExtensionTemplate.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### dataExtensionTemplate.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### dataExtensionTemplate.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### dataExtensionTemplate.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### dataExtensionTemplate.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>DataExtensionTemplate</code>](#DataExtensionTemplate)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="DataExtract"></a>

## DataExtract ⇐ [<code>MetadataType</code>](#MetadataType)
DataExtract MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [DataExtract](#DataExtract) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#DataExtract+retrieve) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.retrieveForCache()](#DataExtract+retrieveForCache) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables)](#DataExtract+retrieveAsTemplate) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postRetrieveTasks(fileTransfer)](#DataExtract+postRetrieveTasks) ⇒ <code>Array.&lt;Object&gt;</code>
    * [.create(dataExtract)](#DataExtract+create) ⇒ <code>Promise</code>
    * [.update(dataExtract)](#DataExtract+update) ⇒ <code>Promise</code>
    * [.preDeployTasks(metadata)](#DataExtract+preDeployTasks) ⇒ <code>Object</code>
    * [.parseMetadata(metadata)](#DataExtract+parseMetadata) ⇒ <code>Array</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="DataExtract+retrieve"></a>

### dataExtract.retrieve(retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves Metadata of Data Extract Activity.
Endpoint /automation/v1/dataextracts/ returns all Data Extracts

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="DataExtract+retrieveForCache"></a>

### dataExtract.retrieveForCache() ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves Metadata of  Data Extract Activity for caching

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  
<a name="DataExtract+retrieveAsTemplate"></a>

### dataExtract.retrieveAsTemplate(templateDir, name, templateVariables) ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieve a specific dataExtract Definition by Name

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Overrides**: [<code>retrieveAsTemplate</code>](#MetadataType+retrieveAsTemplate)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>String</code> | Directory where retrieved metadata directory will be saved |
| name | <code>String</code> | name of the metadata file |
| templateVariables | <code>Object</code> | variables to be replaced in the metadata |

<a name="DataExtract+postRetrieveTasks"></a>

### dataExtract.postRetrieveTasks(fileTransfer) ⇒ <code>Array.&lt;Object&gt;</code>
manages post retrieve steps

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Overrides**: [<code>postRetrieveTasks</code>](#MetadataType+postRetrieveTasks)  
**Returns**: <code>Array.&lt;Object&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| fileTransfer | <code>Object</code> | a single fileTransfer |

<a name="DataExtract+create"></a>

### dataExtract.create(dataExtract) ⇒ <code>Promise</code>
Creates a single Data Extract

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Overrides**: [<code>create</code>](#MetadataType+create)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| dataExtract | <code>Object</code> | a single Data Extract |

<a name="DataExtract+update"></a>

### dataExtract.update(dataExtract) ⇒ <code>Promise</code>
Updates a single Data Extract

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Overrides**: [<code>update</code>](#MetadataType+update)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| dataExtract | <code>Object</code> | a single Data Extract |

<a name="DataExtract+preDeployTasks"></a>

### dataExtract.preDeployTasks(metadata) ⇒ <code>Object</code>
prepares a dataExtract for deployment

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Overrides**: [<code>preDeployTasks</code>](#MetadataType+preDeployTasks)  
**Returns**: <code>Object</code> - metadata object  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single dataExtract activity definition |

<a name="DataExtract+parseMetadata"></a>

### dataExtract.parseMetadata(metadata) ⇒ <code>Array</code>
parses retrieved Metadata before saving

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Array</code> - Array with one metadata object and one sql string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single dataExtract activity definition |

<a name="MetadataType+getJsonFromFS"></a>

### dataExtract.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### dataExtract.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### dataExtract.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### dataExtract.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+overrideKeyWithName"></a>

### dataExtract.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### dataExtract.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+upsert"></a>

### dataExtract.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### dataExtract.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### dataExtract.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### dataExtract.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### dataExtract.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### dataExtract.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### dataExtract.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### dataExtract.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### dataExtract.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### dataExtract.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### dataExtract.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### dataExtract.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### dataExtract.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### dataExtract.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### dataExtract.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### dataExtract.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### dataExtract.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### dataExtract.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### dataExtract.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### dataExtract.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### dataExtract.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### dataExtract.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### dataExtract.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### dataExtract.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### dataExtract.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### dataExtract.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>DataExtract</code>](#DataExtract)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="DataExtractType"></a>

## DataExtractType ⇐ [<code>MetadataType</code>](#MetadataType)
DataExtractType MetadataType
Only for Caching No retrieve/upsert is required
as this is a configuration in the EID

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [DataExtractType](#DataExtractType) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#DataExtractType+retrieve) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.retrieveForCache()](#DataExtractType+retrieveForCache) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.postRetrieveTasks(metadata, targetDir, [isTemplating])](#MetadataType+postRetrieveTasks) ⇒ <code>Util.MetadataTypeItem</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
    * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
    * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="DataExtractType+retrieve"></a>

### dataExtractType.retrieve(retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves Metadata of  Data Extract Type.

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="DataExtractType+retrieveForCache"></a>

### dataExtractType.retrieveForCache() ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves Metadata of  Data Extract Type for caching.

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  
<a name="MetadataType+getJsonFromFS"></a>

### dataExtractType.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### dataExtractType.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### dataExtractType.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### dataExtractType.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+postRetrieveTasks"></a>

### dataExtractType.postRetrieveTasks(metadata, targetDir, [isTemplating]) ⇒ <code>Util.MetadataTypeItem</code>
Gets executed after retreive of metadata type

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Util.MetadataTypeItem</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| targetDir | <code>string</code> | folder where retrieves should be saved |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="MetadataType+overrideKeyWithName"></a>

### dataExtractType.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### dataExtractType.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### dataExtractType.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### dataExtractType.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### dataExtractType.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### dataExtractType.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### dataExtractType.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### dataExtractType.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### dataExtractType.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### dataExtractType.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### dataExtractType.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### dataExtractType.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### dataExtractType.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### dataExtractType.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### dataExtractType.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### dataExtractType.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### dataExtractType.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### dataExtractType.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### dataExtractType.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### dataExtractType.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### dataExtractType.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### dataExtractType.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### dataExtractType.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### dataExtractType.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### dataExtractType.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### dataExtractType.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### dataExtractType.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### dataExtractType.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### dataExtractType.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### dataExtractType.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### dataExtractType.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### dataExtractType.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>DataExtractType</code>](#DataExtractType)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="Discovery"></a>

## Discovery ⇐ [<code>MetadataType</code>](#MetadataType)
ImportFile MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Discovery](#Discovery) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#Discovery+retrieve) ⇒ <code>Promise</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.postRetrieveTasks(metadata, targetDir, [isTemplating])](#MetadataType+postRetrieveTasks) ⇒ <code>Util.MetadataTypeItem</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveForCache([subType])](#MetadataType+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
    * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
    * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="Discovery+retrieve"></a>

### discovery.retrieve(retrieveDir) ⇒ <code>Promise</code>
Retrieves API endpoint
documentation: https://developer.salesforce.com/docs/atlas.en-us.noversion.mc-apis.meta/mc-apis/routes.htm

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="MetadataType+getJsonFromFS"></a>

### discovery.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### discovery.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### discovery.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### discovery.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+postRetrieveTasks"></a>

### discovery.postRetrieveTasks(metadata, targetDir, [isTemplating]) ⇒ <code>Util.MetadataTypeItem</code>
Gets executed after retreive of metadata type

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Util.MetadataTypeItem</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| targetDir | <code>string</code> | folder where retrieves should be saved |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="MetadataType+overrideKeyWithName"></a>

### discovery.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### discovery.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveForCache"></a>

### discovery.retrieveForCache([subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### discovery.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### discovery.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### discovery.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### discovery.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### discovery.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### discovery.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### discovery.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### discovery.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### discovery.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### discovery.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### discovery.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### discovery.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### discovery.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### discovery.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### discovery.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### discovery.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### discovery.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### discovery.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### discovery.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### discovery.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### discovery.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### discovery.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### discovery.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### discovery.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### discovery.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### discovery.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### discovery.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### discovery.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### discovery.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### discovery.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>Discovery</code>](#Discovery)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="Email"></a>

## Email ⇐ [<code>MetadataType</code>](#MetadataType)
Email MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Email](#Email) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#Email+retrieve) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postRetrieveTasks(metadata)](#Email+postRetrieveTasks) ⇒ <code>Array.&lt;Object&gt;</code>
    * [.parseMetadata(metadata)](#Email+parseMetadata) ⇒ <code>Array</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveForCache([subType])](#MetadataType+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
    * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
    * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="Email+retrieve"></a>

### email.retrieve(retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves SOAP based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>Email</code>](#Email)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="Email+postRetrieveTasks"></a>

### email.postRetrieveTasks(metadata) ⇒ <code>Array.&lt;Object&gt;</code>
manages post retrieve steps

**Kind**: instance method of [<code>Email</code>](#Email)  
**Overrides**: [<code>postRetrieveTasks</code>](#MetadataType+postRetrieveTasks)  
**Returns**: <code>Array.&lt;Object&gt;</code> - Array with one metadata object and one query string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single query |

<a name="Email+parseMetadata"></a>

### email.parseMetadata(metadata) ⇒ <code>Array</code>
parses retrieved Metadata before saving

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Array</code> - Array with one metadata object and one sql string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single query activity definition |

<a name="MetadataType+getJsonFromFS"></a>

### email.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### email.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### email.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### email.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>Email</code>](#Email)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+overrideKeyWithName"></a>

### email.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>Email</code>](#Email)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### email.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveForCache"></a>

### email.retrieveForCache([subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### email.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### email.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### email.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>Email</code>](#Email)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### email.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>Email</code>](#Email)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### email.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### email.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### email.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### email.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### email.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### email.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### email.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### email.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### email.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>Email</code>](#Email)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### email.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>Email</code>](#Email)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### email.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>Email</code>](#Email)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### email.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>Email</code>](#Email)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### email.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>Email</code>](#Email)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### email.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### email.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### email.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### email.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### email.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### email.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### email.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### email.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### email.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Email</code>](#Email)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### email.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### email.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### email.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### email.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>Email</code>](#Email)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="EmailSendDefinition"></a>

## EmailSendDefinition ⇐ [<code>MetadataType</code>](#MetadataType)
MessageSendActivity MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [EmailSendDefinition](#EmailSendDefinition) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#EmailSendDefinition+retrieve) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.update(metadataItem)](#EmailSendDefinition+update) ⇒ <code>Promise</code>
    * [.create(metadataItem)](#EmailSendDefinition+create) ⇒ <code>Promise</code>
    * [.deleteByKey(customerKey)](#EmailSendDefinition+deleteByKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.preDeployTasks(metadata)](#EmailSendDefinition+preDeployTasks) ⇒ <code>Promise</code>
    * [.postRetrieveTasks(metadata)](#EmailSendDefinition+postRetrieveTasks) ⇒ <code>Array.&lt;Object&gt;</code>
    * [.parseMetadata(metadata)](#EmailSendDefinition+parseMetadata) ⇒ <code>Array</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveForCache([subType])](#MetadataType+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="EmailSendDefinition+retrieve"></a>

### emailSendDefinition.retrieve(retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves SOAP based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="EmailSendDefinition+update"></a>

### emailSendDefinition.update(metadataItem) ⇒ <code>Promise</code>
Updates a single item

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Overrides**: [<code>update</code>](#MetadataType+update)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataItem | <code>Object</code> | a single item |

<a name="EmailSendDefinition+create"></a>

### emailSendDefinition.create(metadataItem) ⇒ <code>Promise</code>
Creates a single item

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Overrides**: [<code>create</code>](#MetadataType+create)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataItem | <code>Object</code> | a single item |

<a name="EmailSendDefinition+deleteByKey"></a>

### emailSendDefinition.deleteByKey(customerKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Overrides**: [<code>deleteByKey</code>](#MetadataType+deleteByKey)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="EmailSendDefinition+preDeployTasks"></a>

### emailSendDefinition.preDeployTasks(metadata) ⇒ <code>Promise</code>
prepares a single item for deployment

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Overrides**: [<code>preDeployTasks</code>](#MetadataType+preDeployTasks)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single script activity definition |

<a name="EmailSendDefinition+postRetrieveTasks"></a>

### emailSendDefinition.postRetrieveTasks(metadata) ⇒ <code>Array.&lt;Object&gt;</code>
manages post retrieve steps

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Overrides**: [<code>postRetrieveTasks</code>](#MetadataType+postRetrieveTasks)  
**Returns**: <code>Array.&lt;Object&gt;</code> - Array with one metadata object and one query string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single query |

<a name="EmailSendDefinition+parseMetadata"></a>

### emailSendDefinition.parseMetadata(metadata) ⇒ <code>Array</code>
parses retrieved Metadata before saving

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Array</code> - Array with one metadata object and one sql string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single query activity definition |

<a name="MetadataType+getJsonFromFS"></a>

### emailSendDefinition.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### emailSendDefinition.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### emailSendDefinition.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### emailSendDefinition.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+overrideKeyWithName"></a>

### emailSendDefinition.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### emailSendDefinition.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveForCache"></a>

### emailSendDefinition.retrieveForCache([subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### emailSendDefinition.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+upsert"></a>

### emailSendDefinition.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### emailSendDefinition.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### emailSendDefinition.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### emailSendDefinition.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### emailSendDefinition.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### emailSendDefinition.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### emailSendDefinition.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### emailSendDefinition.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### emailSendDefinition.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### emailSendDefinition.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### emailSendDefinition.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### emailSendDefinition.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### emailSendDefinition.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### emailSendDefinition.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### emailSendDefinition.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### emailSendDefinition.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### emailSendDefinition.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### emailSendDefinition.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### emailSendDefinition.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### emailSendDefinition.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### emailSendDefinition.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### emailSendDefinition.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+postDeleteTasks"></a>

### emailSendDefinition.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### emailSendDefinition.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### emailSendDefinition.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>EmailSendDefinition</code>](#EmailSendDefinition)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="EventDefinition"></a>

## EventDefinition ⇐ [<code>MetadataType</code>](#MetadataType)
EventDefinition MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [EventDefinition](#EventDefinition) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#EventDefinition+retrieve) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.retrieveForCache()](#EventDefinition+retrieveForCache) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables)](#EventDefinition+retrieveAsTemplate) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postRetrieveTasks(eventDef)](#EventDefinition+postRetrieveTasks) ⇒ <code>Array.&lt;Object&gt;</code>
    * [.create(EventDefinition)](#EventDefinition+create) ⇒ <code>Promise</code>
    * [.update(metadataEntry)](#EventDefinition+update) ⇒ <code>Promise</code>
    * [.preDeployTasks(metadata)](#EventDefinition+preDeployTasks) ⇒ <code>Promise</code>
    * [.parseMetadata(metadata)](#EventDefinition+parseMetadata) ⇒ <code>Array</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="EventDefinition+retrieve"></a>

### eventDefinition.retrieve(retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves Metadata of Event Definition.
Endpoint /interaction/v1/EventDefinitions return all Event Definitions with all details.
Currently it is not needed to loop over Imports with endpoint /interaction/v1/EventDefinitions/{id}

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="EventDefinition+retrieveForCache"></a>

### eventDefinition.retrieveForCache() ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves event definition metadata for caching

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  
<a name="EventDefinition+retrieveAsTemplate"></a>

### eventDefinition.retrieveAsTemplate(templateDir, name, templateVariables) ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieve a specific Event Definition by Name

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Overrides**: [<code>retrieveAsTemplate</code>](#MetadataType+retrieveAsTemplate)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>String</code> | Directory where retrieved metadata directory will be saved |
| name | <code>String</code> | name of the metadata file |
| templateVariables | <code>Object</code> | variables to be replaced in the metadata |

<a name="EventDefinition+postRetrieveTasks"></a>

### eventDefinition.postRetrieveTasks(eventDef) ⇒ <code>Array.&lt;Object&gt;</code>
manages post retrieve steps

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Overrides**: [<code>postRetrieveTasks</code>](#MetadataType+postRetrieveTasks)  
**Returns**: <code>Array.&lt;Object&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| eventDef | <code>Object</code> | a single importDef |

<a name="EventDefinition+create"></a>

### eventDefinition.create(EventDefinition) ⇒ <code>Promise</code>
Creates a single Event Definition

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Overrides**: [<code>create</code>](#MetadataType+create)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| EventDefinition | <code>Util.MetadataTypeItem</code> | a single Event Definition |

<a name="EventDefinition+update"></a>

### eventDefinition.update(metadataEntry) ⇒ <code>Promise</code>
Updates a single Event Definition (using PUT method since PATCH isn't supported)

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Overrides**: [<code>update</code>](#MetadataType+update)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single Event Definition |

<a name="EventDefinition+preDeployTasks"></a>

### eventDefinition.preDeployTasks(metadata) ⇒ <code>Promise</code>
prepares an event definition for deployment

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Overrides**: [<code>preDeployTasks</code>](#MetadataType+preDeployTasks)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single eventDefinition |

<a name="EventDefinition+parseMetadata"></a>

### eventDefinition.parseMetadata(metadata) ⇒ <code>Array</code>
parses retrieved Metadata before saving

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Array</code> - Array with one metadata object and one sql string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single event definition |

<a name="MetadataType+getJsonFromFS"></a>

### eventDefinition.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### eventDefinition.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### eventDefinition.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### eventDefinition.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+overrideKeyWithName"></a>

### eventDefinition.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### eventDefinition.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+upsert"></a>

### eventDefinition.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### eventDefinition.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### eventDefinition.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### eventDefinition.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### eventDefinition.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### eventDefinition.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### eventDefinition.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### eventDefinition.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### eventDefinition.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### eventDefinition.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### eventDefinition.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### eventDefinition.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### eventDefinition.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### eventDefinition.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### eventDefinition.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### eventDefinition.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### eventDefinition.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### eventDefinition.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### eventDefinition.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### eventDefinition.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### eventDefinition.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### eventDefinition.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### eventDefinition.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### eventDefinition.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### eventDefinition.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### eventDefinition.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>EventDefinition</code>](#EventDefinition)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="FileTransfer"></a>

## FileTransfer ⇐ [<code>MetadataType</code>](#MetadataType)
FileTransfer MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [FileTransfer](#FileTransfer) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#FileTransfer+retrieve) ⇒ <code>Promise</code>
    * [.retrieveForCache()](#FileTransfer+retrieveForCache) ⇒ <code>Promise</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables)](#FileTransfer+retrieveAsTemplate) ⇒ <code>Promise</code>
    * [.postRetrieveTasks(metadata)](#FileTransfer+postRetrieveTasks) ⇒ <code>Array.&lt;Object&gt;</code>
    * [.create(fileTransfer)](#FileTransfer+create) ⇒ <code>Promise</code>
    * [.update(fileTransfer)](#FileTransfer+update) ⇒ <code>Promise</code>
    * [.preDeployTasks(metadata)](#FileTransfer+preDeployTasks) ⇒ <code>Promise</code>
    * [.parseMetadata(metadata)](#FileTransfer+parseMetadata) ⇒ <code>Array</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="FileTransfer+retrieve"></a>

### fileTransfer.retrieve(retrieveDir) ⇒ <code>Promise</code>
Retrieves Metadata of FileTransfer Activity.
Endpoint /automation/v1/filetransfers/ returns all File Transfers

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="FileTransfer+retrieveForCache"></a>

### fileTransfer.retrieveForCache() ⇒ <code>Promise</code>
Retrieves Metadata of  FileTransfer Activity for caching

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise</code> - Promise  
<a name="FileTransfer+retrieveAsTemplate"></a>

### fileTransfer.retrieveAsTemplate(templateDir, name, templateVariables) ⇒ <code>Promise</code>
Retrieve a specific File Transfer Definition by Name

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Overrides**: [<code>retrieveAsTemplate</code>](#MetadataType+retrieveAsTemplate)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>String</code> | Directory where retrieved metadata directory will be saved |
| name | <code>String</code> | name of the metadata file |
| templateVariables | <code>Object</code> | variables to be replaced in the metadata |

<a name="FileTransfer+postRetrieveTasks"></a>

### fileTransfer.postRetrieveTasks(metadata) ⇒ <code>Array.&lt;Object&gt;</code>
manages post retrieve steps

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Overrides**: [<code>postRetrieveTasks</code>](#MetadataType+postRetrieveTasks)  
**Returns**: <code>Array.&lt;Object&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single fileTransfer activity definition |

<a name="FileTransfer+create"></a>

### fileTransfer.create(fileTransfer) ⇒ <code>Promise</code>
Creates a single File Transfer

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Overrides**: [<code>create</code>](#MetadataType+create)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| fileTransfer | <code>Util.MetadataTypeItem</code> | a single File Transfer |

<a name="FileTransfer+update"></a>

### fileTransfer.update(fileTransfer) ⇒ <code>Promise</code>
Updates a single File Transfer

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Overrides**: [<code>update</code>](#MetadataType+update)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| fileTransfer | <code>Util.MetadataTypeItem</code> | a single File Transfer |

<a name="FileTransfer+preDeployTasks"></a>

### fileTransfer.preDeployTasks(metadata) ⇒ <code>Promise</code>
prepares a fileTransfer for deployment

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Overrides**: [<code>preDeployTasks</code>](#MetadataType+preDeployTasks)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single fileTransfer activity definition |

<a name="FileTransfer+parseMetadata"></a>

### fileTransfer.parseMetadata(metadata) ⇒ <code>Array</code>
parses retrieved Metadata before saving

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Array</code> - Array with one metadata object and one sql string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single fileTransfer activity definition |

<a name="MetadataType+getJsonFromFS"></a>

### fileTransfer.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### fileTransfer.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### fileTransfer.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### fileTransfer.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+overrideKeyWithName"></a>

### fileTransfer.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### fileTransfer.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+upsert"></a>

### fileTransfer.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### fileTransfer.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### fileTransfer.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### fileTransfer.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### fileTransfer.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### fileTransfer.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### fileTransfer.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### fileTransfer.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### fileTransfer.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### fileTransfer.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### fileTransfer.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### fileTransfer.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### fileTransfer.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### fileTransfer.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### fileTransfer.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### fileTransfer.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### fileTransfer.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### fileTransfer.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### fileTransfer.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### fileTransfer.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### fileTransfer.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### fileTransfer.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### fileTransfer.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### fileTransfer.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### fileTransfer.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### fileTransfer.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>FileTransfer</code>](#FileTransfer)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="Filter"></a>

## Filter ⇐ [<code>MetadataType</code>](#MetadataType)
Filter MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Filter](#Filter) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#Filter+retrieve) ⇒ <code>Promise</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.postRetrieveTasks(metadata, targetDir, [isTemplating])](#MetadataType+postRetrieveTasks) ⇒ <code>Util.MetadataTypeItem</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveForCache([subType])](#MetadataType+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
    * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
    * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="Filter+retrieve"></a>

### filter.retrieve(retrieveDir) ⇒ <code>Promise</code>
Retrieves Metadata of Filter.
Endpoint /automation/v1/filters/ returns all Filters,
but only with some of the fields. So it is needed to loop over
Filters with the endpoint /automation/v1/filters/{id}

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="MetadataType+getJsonFromFS"></a>

### filter.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### filter.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### filter.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### filter.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>Filter</code>](#Filter)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+postRetrieveTasks"></a>

### filter.postRetrieveTasks(metadata, targetDir, [isTemplating]) ⇒ <code>Util.MetadataTypeItem</code>
Gets executed after retreive of metadata type

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Util.MetadataTypeItem</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| targetDir | <code>string</code> | folder where retrieves should be saved |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="MetadataType+overrideKeyWithName"></a>

### filter.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>Filter</code>](#Filter)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### filter.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveForCache"></a>

### filter.retrieveForCache([subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### filter.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### filter.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### filter.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>Filter</code>](#Filter)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### filter.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>Filter</code>](#Filter)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### filter.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### filter.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### filter.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### filter.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### filter.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### filter.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### filter.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### filter.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### filter.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>Filter</code>](#Filter)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### filter.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>Filter</code>](#Filter)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### filter.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>Filter</code>](#Filter)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### filter.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>Filter</code>](#Filter)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### filter.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>Filter</code>](#Filter)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### filter.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### filter.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### filter.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### filter.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### filter.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### filter.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### filter.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### filter.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### filter.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Filter</code>](#Filter)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### filter.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### filter.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### filter.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### filter.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>Filter</code>](#Filter)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="Folder"></a>

## Folder ⇐ [<code>MetadataType</code>](#MetadataType)
Folder MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Folder](#Folder) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir, [additionalFields])](#Folder+retrieve) ⇒ <code>Promise</code>
    * [.retrieveForCache()](#Folder+retrieveForCache) ⇒ <code>Promise</code>
    * [.upsert(metadata)](#Folder+upsert) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.create(metadataEntry)](#Folder+create) ⇒ <code>Promise</code>
    * [.update(metadataEntry)](#Folder+update) ⇒ <code>Promise</code>
    * [.preDeployTasks(metadata)](#Folder+preDeployTasks) ⇒ <code>Promise</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#Folder+getJsonFromFS) ⇒ <code>Object</code>
    * [.retrieveHelper([additionalFields], [queryAllAccounts])](#Folder+retrieveHelper) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postRetrieveTasks(metadata)](#Folder+postRetrieveTasks) ⇒ <code>Array.&lt;Object&gt;</code>
    * [.saveResults(results, retrieveDir, mid)](#Folder+saveResults) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="Folder+retrieve"></a>

### folder.retrieve(retrieveDir, [additionalFields]) ⇒ <code>Promise</code>
Retrieves metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |
| [additionalFields] | <code>Array.&lt;String&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="Folder+retrieveForCache"></a>

### folder.retrieveForCache() ⇒ <code>Promise</code>
Retrieves folder metadata for caching

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise</code> - Promise  
<a name="Folder+upsert"></a>

### folder.upsert(metadata) ⇒ <code>Promise.&lt;Object&gt;</code>
Folder upsert (copied from Metadata Upsert), after retrieving from target
and comparing to check if create or update operation is needed.
Copied due to having a dependency on itself, meaning the created need to be serial

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Overrides**: [<code>upsert</code>](#MetadataType+upsert)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |

<a name="Folder+create"></a>

### folder.create(metadataEntry) ⇒ <code>Promise</code>
creates a folder based on metatadata

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Overrides**: [<code>create</code>](#MetadataType+create)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata of the folder |

<a name="Folder+update"></a>

### folder.update(metadataEntry) ⇒ <code>Promise</code>
Updates a single Folder.

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Overrides**: [<code>update</code>](#MetadataType+update)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |

<a name="Folder+preDeployTasks"></a>

### folder.preDeployTasks(metadata) ⇒ <code>Promise</code>
prepares a folder for deployment

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Overrides**: [<code>preDeployTasks</code>](#MetadataType+preDeployTasks)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single folder definition |

<a name="Folder+getJsonFromFS"></a>

### folder.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Overrides**: [<code>getJsonFromFS</code>](#MetadataType+getJsonFromFS)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>String</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="Folder+retrieveHelper"></a>

### folder.retrieveHelper([additionalFields], [queryAllAccounts]) ⇒ <code>Promise.&lt;Object&gt;</code>
Helper to retrieve the folders as promise

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - soap object  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;String&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [queryAllAccounts] | <code>Boolean</code> | which queryAllAccounts setting to use |

<a name="Folder+postRetrieveTasks"></a>

### folder.postRetrieveTasks(metadata) ⇒ <code>Array.&lt;Object&gt;</code>
Gets executed after retreive of metadata type

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Overrides**: [<code>postRetrieveTasks</code>](#MetadataType+postRetrieveTasks)  
**Returns**: <code>Array.&lt;Object&gt;</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | metadata mapped by their keyField |

<a name="Folder+saveResults"></a>

### folder.saveResults(results, retrieveDir, mid) ⇒ <code>Promise.&lt;Object&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Overrides**: [<code>saveResults</code>](#MetadataType+saveResults)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Object</code> | metadata results from deploy |
| retrieveDir | <code>String</code> | directory where metadata should be stored after deploy/retrieve |
| mid | <code>Number</code> | current mid for this credential / business unit |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### folder.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### folder.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### folder.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>Folder</code>](#Folder)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+overrideKeyWithName"></a>

### folder.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>Folder</code>](#Folder)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### folder.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### folder.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+createREST"></a>

### folder.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### folder.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### folder.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### folder.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### folder.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### folder.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### folder.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### folder.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>Folder</code>](#Folder)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### folder.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>Folder</code>](#Folder)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### folder.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>Folder</code>](#Folder)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### folder.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>Folder</code>](#Folder)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### folder.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>Folder</code>](#Folder)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### folder.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### folder.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### folder.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### folder.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### folder.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### folder.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### folder.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### folder.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Folder</code>](#Folder)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### folder.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### folder.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### folder.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### folder.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>Folder</code>](#Folder)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="FtpLocation"></a>

## FtpLocation ⇐ [<code>MetadataType</code>](#MetadataType)
ImportFile MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [FtpLocation](#FtpLocation) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#FtpLocation+retrieve) ⇒ <code>Promise</code>
    * [.retrieveForCache()](#FtpLocation+retrieveForCache) ⇒ <code>Promise</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.postRetrieveTasks(metadata, targetDir, [isTemplating])](#MetadataType+postRetrieveTasks) ⇒ <code>Util.MetadataTypeItem</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
    * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
    * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="FtpLocation+retrieve"></a>

### ftpLocation.retrieve(retrieveDir) ⇒ <code>Promise</code>
Retrieves Metadata of FtpLocation
Endpoint /automation/v1/ftplocations/ return all FtpLocations

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="FtpLocation+retrieveForCache"></a>

### ftpLocation.retrieveForCache() ⇒ <code>Promise</code>
Retrieves folder metadata into local filesystem. Also creates a uniquePath attribute for each folder.

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise</code> - Promise  
<a name="MetadataType+getJsonFromFS"></a>

### ftpLocation.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### ftpLocation.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### ftpLocation.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### ftpLocation.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+postRetrieveTasks"></a>

### ftpLocation.postRetrieveTasks(metadata, targetDir, [isTemplating]) ⇒ <code>Util.MetadataTypeItem</code>
Gets executed after retreive of metadata type

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Util.MetadataTypeItem</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| targetDir | <code>string</code> | folder where retrieves should be saved |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="MetadataType+overrideKeyWithName"></a>

### ftpLocation.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### ftpLocation.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### ftpLocation.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### ftpLocation.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### ftpLocation.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### ftpLocation.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### ftpLocation.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### ftpLocation.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### ftpLocation.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### ftpLocation.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### ftpLocation.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### ftpLocation.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### ftpLocation.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### ftpLocation.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### ftpLocation.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### ftpLocation.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### ftpLocation.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### ftpLocation.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### ftpLocation.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### ftpLocation.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### ftpLocation.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### ftpLocation.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### ftpLocation.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### ftpLocation.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### ftpLocation.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### ftpLocation.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### ftpLocation.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### ftpLocation.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### ftpLocation.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### ftpLocation.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### ftpLocation.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### ftpLocation.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>FtpLocation</code>](#FtpLocation)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="ImportFile"></a>

## ImportFile ⇐ [<code>MetadataType</code>](#MetadataType)
ImportFile MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [ImportFile](#ImportFile) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#ImportFile+retrieve) ⇒ <code>Promise</code>
    * [.retrieveForCache()](#ImportFile+retrieveForCache) ⇒ <code>Promise</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables)](#ImportFile+retrieveAsTemplate) ⇒ <code>Promise</code>
    * [.postRetrieveTasks(importDef)](#ImportFile+postRetrieveTasks) ⇒ <code>Array.&lt;Object&gt;</code>
    * [.create(importFile)](#ImportFile+create) ⇒ <code>Promise</code>
    * [.update(importFile)](#ImportFile+update) ⇒ <code>Promise</code>
    * [.preDeployTasks(metadata)](#ImportFile+preDeployTasks) ⇒ <code>Promise</code>
    * [.parseMetadata(metadata)](#ImportFile+parseMetadata) ⇒ <code>Object</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="ImportFile+retrieve"></a>

### importFile.retrieve(retrieveDir) ⇒ <code>Promise</code>
Retrieves Metadata of Import File.
Endpoint /automation/v1/imports/ return all Import Files with all details.
Currently it is not needed to loop over Imports with endpoint /automation/v1/imports/{id}

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="ImportFile+retrieveForCache"></a>

### importFile.retrieveForCache() ⇒ <code>Promise</code>
Retrieves import definition metadata for caching

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise</code> - Promise  
<a name="ImportFile+retrieveAsTemplate"></a>

### importFile.retrieveAsTemplate(templateDir, name, templateVariables) ⇒ <code>Promise</code>
Retrieve a specific Import Definition by Name

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Overrides**: [<code>retrieveAsTemplate</code>](#MetadataType+retrieveAsTemplate)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>String</code> | Directory where retrieved metadata directory will be saved |
| name | <code>String</code> | name of the metadata file |
| templateVariables | <code>Object</code> | variables to be replaced in the metadata |

<a name="ImportFile+postRetrieveTasks"></a>

### importFile.postRetrieveTasks(importDef) ⇒ <code>Array.&lt;Object&gt;</code>
manages post retrieve steps

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Overrides**: [<code>postRetrieveTasks</code>](#MetadataType+postRetrieveTasks)  
**Returns**: <code>Array.&lt;Object&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| importDef | <code>Object</code> | a single importDef |

<a name="ImportFile+create"></a>

### importFile.create(importFile) ⇒ <code>Promise</code>
Creates a single Import File

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Overrides**: [<code>create</code>](#MetadataType+create)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| importFile | <code>Object</code> | a single Import File |

<a name="ImportFile+update"></a>

### importFile.update(importFile) ⇒ <code>Promise</code>
Updates a single Import File

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Overrides**: [<code>update</code>](#MetadataType+update)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| importFile | <code>Object</code> | a single Import File |

<a name="ImportFile+preDeployTasks"></a>

### importFile.preDeployTasks(metadata) ⇒ <code>Promise</code>
prepares a import definition for deployment

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Overrides**: [<code>preDeployTasks</code>](#MetadataType+preDeployTasks)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single importDef |

<a name="ImportFile+parseMetadata"></a>

### importFile.parseMetadata(metadata) ⇒ <code>Object</code>
parses retrieved Metadata before saving

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Object</code> - parsed metadata definition  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single import definition |

<a name="MetadataType+getJsonFromFS"></a>

### importFile.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### importFile.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### importFile.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### importFile.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+overrideKeyWithName"></a>

### importFile.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### importFile.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+upsert"></a>

### importFile.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### importFile.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### importFile.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### importFile.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### importFile.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### importFile.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### importFile.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### importFile.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### importFile.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### importFile.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### importFile.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### importFile.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### importFile.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### importFile.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### importFile.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### importFile.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### importFile.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### importFile.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### importFile.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### importFile.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### importFile.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### importFile.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### importFile.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### importFile.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### importFile.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### importFile.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>ImportFile</code>](#ImportFile)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="Interaction"></a>

## Interaction ⇐ [<code>MetadataType</code>](#MetadataType)
Script MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Interaction](#Interaction) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#Interaction+retrieve) ⇒ <code>Promise</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.postRetrieveTasks(metadata, targetDir, [isTemplating])](#MetadataType+postRetrieveTasks) ⇒ <code>Util.MetadataTypeItem</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveForCache([subType])](#MetadataType+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
    * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
    * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="Interaction+retrieve"></a>

### interaction.retrieve(retrieveDir) ⇒ <code>Promise</code>
Retrieves Metadata of Interaction
Endpoint /interaction/v1/interactions?extras=all&pageSize=50000 return 50000 Scripts with all details.

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="MetadataType+getJsonFromFS"></a>

### interaction.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### interaction.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### interaction.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### interaction.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+postRetrieveTasks"></a>

### interaction.postRetrieveTasks(metadata, targetDir, [isTemplating]) ⇒ <code>Util.MetadataTypeItem</code>
Gets executed after retreive of metadata type

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Util.MetadataTypeItem</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| targetDir | <code>string</code> | folder where retrieves should be saved |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="MetadataType+overrideKeyWithName"></a>

### interaction.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### interaction.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveForCache"></a>

### interaction.retrieveForCache([subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### interaction.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### interaction.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### interaction.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### interaction.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### interaction.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### interaction.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### interaction.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### interaction.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### interaction.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### interaction.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### interaction.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### interaction.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### interaction.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### interaction.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### interaction.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### interaction.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### interaction.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### interaction.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### interaction.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### interaction.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### interaction.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### interaction.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### interaction.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### interaction.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### interaction.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### interaction.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### interaction.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### interaction.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### interaction.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### interaction.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>Interaction</code>](#Interaction)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="List"></a>

## List ⇐ [<code>MetadataType</code>](#MetadataType)
List MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [List](#List) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#List+retrieve) ⇒ <code>Promise</code>
    * [.retrieveForCache()](#List+retrieveForCache) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.deleteByKey(customerKey)](#List+deleteByKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.postRetrieveTasks(list)](#List+postRetrieveTasks) ⇒ <code>Array.&lt;Object&gt;</code>
    * [.parseMetadata(metadata, [parseForCache])](#List+parseMetadata) ⇒ <code>Array</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
    * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
    * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="List+retrieve"></a>

### list.retrieve(retrieveDir) ⇒ <code>Promise</code>
Retrieves Metadata of Lists

**Kind**: instance method of [<code>List</code>](#List)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="List+retrieveForCache"></a>

### list.retrieveForCache() ⇒ <code>Promise.&lt;Object&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>List</code>](#List)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  
<a name="List+deleteByKey"></a>

### list.deleteByKey(customerKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>List</code>](#List)  
**Overrides**: [<code>deleteByKey</code>](#MetadataType+deleteByKey)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="List+postRetrieveTasks"></a>

### list.postRetrieveTasks(list) ⇒ <code>Array.&lt;Object&gt;</code>
manages post retrieve steps

**Kind**: instance method of [<code>List</code>](#List)  
**Overrides**: [<code>postRetrieveTasks</code>](#MetadataType+postRetrieveTasks)  
**Returns**: <code>Array.&lt;Object&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| list | <code>Object</code> | a single list |

<a name="List+parseMetadata"></a>

### list.parseMetadata(metadata, [parseForCache]) ⇒ <code>Array</code>
parses retrieved Metadata before saving

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Array</code> - Array with one metadata object and one sql string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single list definition |
| [parseForCache] | <code>Boolean</code> | if set to true, the Category ID is kept |

<a name="MetadataType+getJsonFromFS"></a>

### list.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### list.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### list.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### list.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>List</code>](#List)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+overrideKeyWithName"></a>

### list.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>List</code>](#List)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### list.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### list.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### list.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### list.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>List</code>](#List)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### list.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>List</code>](#List)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### list.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### list.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### list.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### list.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### list.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### list.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### list.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### list.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### list.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>List</code>](#List)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### list.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>List</code>](#List)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### list.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>List</code>](#List)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### list.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>List</code>](#List)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### list.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>List</code>](#List)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### list.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### list.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### list.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### list.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### list.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### list.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### list.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### list.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### list.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>List</code>](#List)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+postDeleteTasks"></a>

### list.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### list.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### list.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>List</code>](#List)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="MetadataType"></a>

## MetadataType
MetadataType class that gets extended by their specific metadata type class.
Provides default functionality that can be overwritten by child metadata type classes

**Kind**: global class  

* [MetadataType](#MetadataType)
    * _instance_
        * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
        * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
        * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
        * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
        * [.postRetrieveTasks(metadata, targetDir, [isTemplating])](#MetadataType+postRetrieveTasks) ⇒ <code>Util.MetadataTypeItem</code>
        * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
        * [.retrieve(retrieveDir, [additionalFields], [subType])](#MetadataType+retrieve) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.retrieveForCache([subType])](#MetadataType+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
        * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
        * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
        * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
        * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
        * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
        * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
        * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
        * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
        * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
        * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
        * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
        * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
        * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
        * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
        * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
        * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
        * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
        * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
        * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
        * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
        * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
        * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
        * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
        * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
        * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>
    * _static_
        * [.client](#MetadataType.client) : <code>Util.SDK</code>
        * [.properties](#MetadataType.properties) : <code>Util.MultiMetadataTypeMap</code>
        * [.subType](#MetadataType.subType) : <code>string</code>
        * [.buObject](#MetadataType.buObject) : <code>Object</code>

<a name="MetadataType+getJsonFromFS"></a>

### metadataType.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### metadataType.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### metadataType.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### metadataType.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+postRetrieveTasks"></a>

### metadataType.postRetrieveTasks(metadata, targetDir, [isTemplating]) ⇒ <code>Util.MetadataTypeItem</code>
Gets executed after retreive of metadata type

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Util.MetadataTypeItem</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| targetDir | <code>string</code> | folder where retrieves should be saved |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="MetadataType+overrideKeyWithName"></a>

### metadataType.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieve"></a>

### metadataType.retrieve(retrieveDir, [additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveChangelog"></a>

### metadataType.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveForCache"></a>

### metadataType.retrieveForCache([subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### metadataType.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### metadataType.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### metadataType.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### metadataType.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### metadataType.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### metadataType.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### metadataType.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### metadataType.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### metadataType.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### metadataType.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### metadataType.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### metadataType.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### metadataType.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### metadataType.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### metadataType.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### metadataType.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### metadataType.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### metadataType.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### metadataType.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### metadataType.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### metadataType.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### metadataType.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### metadataType.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### metadataType.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### metadataType.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### metadataType.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### metadataType.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### metadataType.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### metadataType.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### metadataType.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="MetadataType.client"></a>

### MetadataType.client : <code>Util.SDK</code>
**Kind**: static property of [<code>MetadataType</code>](#MetadataType)  
<a name="MetadataType.properties"></a>

### MetadataType.properties : <code>Util.MultiMetadataTypeMap</code>
**Kind**: static property of [<code>MetadataType</code>](#MetadataType)  
<a name="MetadataType.subType"></a>

### MetadataType.subType : <code>string</code>
**Kind**: static property of [<code>MetadataType</code>](#MetadataType)  
<a name="MetadataType.buObject"></a>

### MetadataType.buObject : <code>Object</code>
**Kind**: static property of [<code>MetadataType</code>](#MetadataType)  
<a name="MobileCode"></a>

## MobileCode ⇐ [<code>MetadataType</code>](#MetadataType)
MobileCode MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [MobileCode](#MobileCode) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#MobileCode+retrieve) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.retrieveForCache()](#MobileCode+retrieveForCache) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.postRetrieveTasks(metadata, targetDir, [isTemplating])](#MetadataType+postRetrieveTasks) ⇒ <code>Util.MetadataTypeItem</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
    * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
    * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="MobileCode+retrieve"></a>

### mobileCode.retrieve(retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves Metadata of Mobile Keywords
Endpoint /legacy/v1/beta/mobile/code/ return all Mobile Codes with all details.

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="MobileCode+retrieveForCache"></a>

### mobileCode.retrieveForCache() ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves event definition metadata for caching

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  
<a name="MetadataType+getJsonFromFS"></a>

### mobileCode.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### mobileCode.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### mobileCode.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### mobileCode.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+postRetrieveTasks"></a>

### mobileCode.postRetrieveTasks(metadata, targetDir, [isTemplating]) ⇒ <code>Util.MetadataTypeItem</code>
Gets executed after retreive of metadata type

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Util.MetadataTypeItem</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| targetDir | <code>string</code> | folder where retrieves should be saved |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="MetadataType+overrideKeyWithName"></a>

### mobileCode.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### mobileCode.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### mobileCode.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### mobileCode.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### mobileCode.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### mobileCode.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### mobileCode.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### mobileCode.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### mobileCode.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### mobileCode.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### mobileCode.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### mobileCode.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### mobileCode.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### mobileCode.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### mobileCode.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### mobileCode.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### mobileCode.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### mobileCode.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### mobileCode.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### mobileCode.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### mobileCode.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### mobileCode.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### mobileCode.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### mobileCode.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### mobileCode.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### mobileCode.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### mobileCode.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### mobileCode.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### mobileCode.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### mobileCode.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### mobileCode.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### mobileCode.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>MobileCode</code>](#MobileCode)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="MobileKeyword"></a>

## MobileKeyword ⇐ [<code>MetadataType</code>](#MetadataType)
MobileKeyword MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [MobileKeyword](#MobileKeyword) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#MobileKeyword+retrieve) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.retrieveForCache()](#MobileKeyword+retrieveForCache) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables)](#MobileKeyword+retrieveAsTemplate) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.create(MobileKeyword)](#MobileKeyword+create) ⇒ <code>Promise</code>
    * [.preDeployTasks(metadata)](#MobileKeyword+preDeployTasks) ⇒ <code>Promise</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.postRetrieveTasks(metadata, targetDir, [isTemplating])](#MetadataType+postRetrieveTasks) ⇒ <code>Util.MetadataTypeItem</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="MobileKeyword+retrieve"></a>

### mobileKeyword.retrieve(retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves Metadata of Mobile Keywords
Endpoint /legacy/v1/beta/mobile/keyword/ return all Mobile Keywords with all details.

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="MobileKeyword+retrieveForCache"></a>

### mobileKeyword.retrieveForCache() ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves event definition metadata for caching

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  
<a name="MobileKeyword+retrieveAsTemplate"></a>

### mobileKeyword.retrieveAsTemplate(templateDir, name, templateVariables) ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieve a specific keyword

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Overrides**: [<code>retrieveAsTemplate</code>](#MetadataType+retrieveAsTemplate)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>String</code> | Directory where retrieved metadata directory will be saved |
| name | <code>String</code> | name of the metadata file |
| templateVariables | <code>Object</code> | variables to be replaced in the metadata |

<a name="MobileKeyword+create"></a>

### mobileKeyword.create(MobileKeyword) ⇒ <code>Promise</code>
Creates a single Event Definition

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Overrides**: [<code>create</code>](#MetadataType+create)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| MobileKeyword | <code>Object</code> | a single Event Definition |

<a name="MobileKeyword+preDeployTasks"></a>

### mobileKeyword.preDeployTasks(metadata) ⇒ <code>Promise</code>
prepares an event definition for deployment

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Overrides**: [<code>preDeployTasks</code>](#MetadataType+preDeployTasks)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single MobileKeyword |

<a name="MetadataType+getJsonFromFS"></a>

### mobileKeyword.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### mobileKeyword.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### mobileKeyword.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### mobileKeyword.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+postRetrieveTasks"></a>

### mobileKeyword.postRetrieveTasks(metadata, targetDir, [isTemplating]) ⇒ <code>Util.MetadataTypeItem</code>
Gets executed after retreive of metadata type

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Util.MetadataTypeItem</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| targetDir | <code>string</code> | folder where retrieves should be saved |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="MetadataType+overrideKeyWithName"></a>

### mobileKeyword.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### mobileKeyword.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+update"></a>

### mobileKeyword.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### mobileKeyword.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### mobileKeyword.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### mobileKeyword.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### mobileKeyword.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### mobileKeyword.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### mobileKeyword.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### mobileKeyword.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### mobileKeyword.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### mobileKeyword.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### mobileKeyword.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### mobileKeyword.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### mobileKeyword.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### mobileKeyword.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### mobileKeyword.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### mobileKeyword.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### mobileKeyword.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### mobileKeyword.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### mobileKeyword.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### mobileKeyword.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### mobileKeyword.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### mobileKeyword.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### mobileKeyword.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### mobileKeyword.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### mobileKeyword.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### mobileKeyword.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### mobileKeyword.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>MobileKeyword</code>](#MobileKeyword)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="Query"></a>

## Query ⇐ [<code>MetadataType</code>](#MetadataType)
Query MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Query](#Query) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#Query+retrieve) ⇒ <code>Promise.&lt;{metadata:QueryMap, type:string}&gt;</code>
    * [.retrieveForCache()](#Query+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:QueryMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables)](#Query+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:QueryMap, type:string}&gt;</code>
    * [.postRetrieveTasks(metadata, _, isTemplating)](#Query+postRetrieveTasks) ⇒ [<code>CodeExtractItem</code>](#CodeExtractItem)
    * [.create(query)](#Query+create) ⇒ <code>Promise</code>
    * [.update(query)](#Query+update) ⇒ <code>Promise</code>
    * [.preDeployTasks(metadata, deployDir)](#Query+preDeployTasks) ⇒ <code>Promise.&lt;QueryItem&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#Query+buildDefinitionForExtracts) ⇒ <code>Promise</code>
    * [.parseMetadata(metadata)](#Query+parseMetadata) ⇒ [<code>CodeExtractItem</code>](#CodeExtractItem)
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="Query+retrieve"></a>

### query.retrieve(retrieveDir) ⇒ <code>Promise.&lt;{metadata:QueryMap, type:string}&gt;</code>
Retrieves Metadata of queries

**Kind**: instance method of [<code>Query</code>](#Query)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;{metadata:QueryMap, type:string}&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |

<a name="Query+retrieveForCache"></a>

### query.retrieveForCache() ⇒ <code>Promise.&lt;{metadata:QueryMap, type:string}&gt;</code>
Retrieves query metadata for caching

**Kind**: instance method of [<code>Query</code>](#Query)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise.&lt;{metadata:QueryMap, type:string}&gt;</code> - Promise of metadata  
<a name="Query+retrieveAsTemplate"></a>

### query.retrieveAsTemplate(templateDir, name, templateVariables) ⇒ <code>Promise.&lt;{metadata:QueryMap, type:string}&gt;</code>
Retrieve a specific Query by Name

**Kind**: instance method of [<code>Query</code>](#Query)  
**Overrides**: [<code>retrieveAsTemplate</code>](#MetadataType+retrieveAsTemplate)  
**Returns**: <code>Promise.&lt;{metadata:QueryMap, type:string}&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="Query+postRetrieveTasks"></a>

### query.postRetrieveTasks(metadata, _, isTemplating) ⇒ [<code>CodeExtractItem</code>](#CodeExtractItem)
manages post retrieve steps

**Kind**: instance method of [<code>Query</code>](#Query)  
**Overrides**: [<code>postRetrieveTasks</code>](#MetadataType+postRetrieveTasks)  
**Returns**: [<code>CodeExtractItem</code>](#CodeExtractItem) - Array with one metadata object and one query string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>QueryItem</code> | a single query |
| _ | <code>string</code> | unused |
| isTemplating | <code>boolean</code> | signals that we are retrieving templates |

<a name="Query+create"></a>

### query.create(query) ⇒ <code>Promise</code>
Creates a single query

**Kind**: instance method of [<code>Query</code>](#Query)  
**Overrides**: [<code>create</code>](#MetadataType+create)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| query | <code>QueryItem</code> | a single query |

<a name="Query+update"></a>

### query.update(query) ⇒ <code>Promise</code>
Updates a single query

**Kind**: instance method of [<code>Query</code>](#Query)  
**Overrides**: [<code>update</code>](#MetadataType+update)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| query | <code>QueryItem</code> | a single query |

<a name="Query+preDeployTasks"></a>

### query.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;QueryItem&gt;</code>
prepares a Query for deployment

**Kind**: instance method of [<code>Query</code>](#Query)  
**Overrides**: [<code>preDeployTasks</code>](#MetadataType+preDeployTasks)  
**Returns**: <code>Promise.&lt;QueryItem&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>QueryItem</code> | a single query activity |
| deployDir | <code>string</code> | directory of deploy files |

<a name="Query+buildDefinitionForExtracts"></a>

### query.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise</code>
helper for buildDefinition
handles extracted code if any are found for complex types

**Kind**: instance method of [<code>Query</code>](#Query)  
**Overrides**: [<code>buildDefinitionForExtracts</code>](#MetadataType+buildDefinitionForExtracts)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>Object</code> | main JSON file that was read from file system |
| variables | <code>Object</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="Query+parseMetadata"></a>

### query.parseMetadata(metadata) ⇒ [<code>CodeExtractItem</code>](#CodeExtractItem)
parses retrieved Metadata before saving

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: [<code>CodeExtractItem</code>](#CodeExtractItem) - a single item with code parts extracted  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>QueryItem</code> | a single query activity definition |

<a name="MetadataType+getJsonFromFS"></a>

### query.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### query.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### query.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### query.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>Query</code>](#Query)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+overrideKeyWithName"></a>

### query.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>Query</code>](#Query)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### query.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+upsert"></a>

### query.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### query.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### query.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### query.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### query.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### query.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### query.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### query.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### query.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>Query</code>](#Query)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### query.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>Query</code>](#Query)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### query.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>Query</code>](#Query)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### query.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>Query</code>](#Query)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### query.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>Query</code>](#Query)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### query.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### query.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### query.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+findSubType"></a>

### query.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### query.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### query.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### query.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### query.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Query</code>](#Query)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### query.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### query.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### query.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### query.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>Query</code>](#Query)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="Role"></a>

## Role ⇐ [<code>MetadataType</code>](#MetadataType)
ImportFile MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Role](#Role) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#Role+retrieve) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.preDeployTasks(metadata)](#Role+preDeployTasks) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.create(metadata)](#Role+create) ⇒ <code>Promise</code>
    * [.update(metadata)](#Role+update) ⇒ <code>Promise</code>
    * [.document([metadata])](#Role+document) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._traverseRoles(role, element, [permission], [isAllowed])](#Role+_traverseRoles) ⇒ <code>void</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.postRetrieveTasks(metadata, targetDir, [isTemplating])](#MetadataType+postRetrieveTasks) ⇒ <code>Util.MetadataTypeItem</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveForCache([subType])](#MetadataType+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="Role+retrieve"></a>

### role.retrieve(retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>Role</code>](#Role)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Metadata store object  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="Role+preDeployTasks"></a>

### role.preDeployTasks(metadata) ⇒ <code>Promise.&lt;Object&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>Role</code>](#Role)  
**Overrides**: [<code>preDeployTasks</code>](#MetadataType+preDeployTasks)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single metadata item |

<a name="Role+create"></a>

### role.create(metadata) ⇒ <code>Promise</code>
Create a single Role.

**Kind**: instance method of [<code>Role</code>](#Role)  
**Overrides**: [<code>create</code>](#MetadataType+create)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | single metadata entry |

<a name="Role+update"></a>

### role.update(metadata) ⇒ <code>Promise</code>
Updates a single Role.

**Kind**: instance method of [<code>Role</code>](#Role)  
**Overrides**: [<code>update</code>](#MetadataType+update)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | single metadata entry |

<a name="Role+document"></a>

### role.document([metadata]) ⇒ <code>Promise.&lt;void&gt;</code>
Creates markdown documentation of all roles

**Kind**: instance method of [<code>Role</code>](#Role)  
**Overrides**: [<code>document</code>](#MetadataType+document)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Object</code> | role definitions |

<a name="Role+_traverseRoles"></a>

### role.\_traverseRoles(role, element, [permission], [isAllowed]) ⇒ <code>void</code>
iterates through permissions to output proper row-names for nested permissionss

**Kind**: instance method of [<code>Role</code>](#Role)  

| Param | Type | Description |
| --- | --- | --- |
| role | <code>string</code> | name of the user role |
| element | <code>object</code> | data of the permission |
| [permission] | <code>string</code> | name of the permission |
| [isAllowed] | <code>string</code> | "true" / "false" from the |

<a name="MetadataType+getJsonFromFS"></a>

### role.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### role.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### role.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### role.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>Role</code>](#Role)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+postRetrieveTasks"></a>

### role.postRetrieveTasks(metadata, targetDir, [isTemplating]) ⇒ <code>Util.MetadataTypeItem</code>
Gets executed after retreive of metadata type

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Util.MetadataTypeItem</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| targetDir | <code>string</code> | folder where retrieves should be saved |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="MetadataType+overrideKeyWithName"></a>

### role.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>Role</code>](#Role)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### role.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveForCache"></a>

### role.retrieveForCache([subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### role.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+upsert"></a>

### role.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### role.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### role.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### role.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### role.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### role.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### role.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### role.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### role.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>Role</code>](#Role)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### role.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>Role</code>](#Role)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### role.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>Role</code>](#Role)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### role.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>Role</code>](#Role)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### role.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>Role</code>](#Role)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### role.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### role.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### role.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### role.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### role.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### role.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### role.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### role.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+deleteByKey"></a>

### role.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### role.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### role.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### role.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>Role</code>](#Role)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="Script"></a>

## Script ⇐ [<code>MetadataType</code>](#MetadataType)
Script MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [Script](#Script) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#Script+retrieve) ⇒ <code>Promise.&lt;{metadata:ScriptMap, type:string}&gt;</code>
    * [.retrieveForCache()](#Script+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:ScriptMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables)](#Script+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:ScriptMap, type:string}&gt;</code>
    * [.postRetrieveTasks(metadata, [_], [isTemplating])](#Script+postRetrieveTasks) ⇒ [<code>CodeExtractItem</code>](#CodeExtractItem)
    * [.update(script)](#Script+update) ⇒ <code>Promise</code>
    * [.create(script)](#Script+create) ⇒ <code>Promise</code>
    * [._mergeCode(metadata, deployDir, [templateName])](#Script+_mergeCode) ⇒ <code>Promise.&lt;String&gt;</code>
    * [.preDeployTasks(metadata, dir)](#Script+preDeployTasks) ⇒ <code>ScriptItem</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#Script+buildDefinitionForExtracts) ⇒ <code>Promise</code>
    * [.parseMetadata(metadata)](#Script+parseMetadata) ⇒ [<code>CodeExtractItem</code>](#CodeExtractItem)
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="Script+retrieve"></a>

### script.retrieve(retrieveDir) ⇒ <code>Promise.&lt;{metadata:ScriptMap, type:string}&gt;</code>
Retrieves Metadata of Script
Endpoint /automation/v1/scripts/ return all Scripts with all details.

**Kind**: instance method of [<code>Script</code>](#Script)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;{metadata:ScriptMap, type:string}&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |

<a name="Script+retrieveForCache"></a>

### script.retrieveForCache() ⇒ <code>Promise.&lt;{metadata:ScriptMap, type:string}&gt;</code>
Retrieves script metadata for caching

**Kind**: instance method of [<code>Script</code>](#Script)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise.&lt;{metadata:ScriptMap, type:string}&gt;</code> - Promise  
<a name="Script+retrieveAsTemplate"></a>

### script.retrieveAsTemplate(templateDir, name, templateVariables) ⇒ <code>Promise.&lt;{metadata:ScriptMap, type:string}&gt;</code>
Retrieve a specific Script by Name

**Kind**: instance method of [<code>Script</code>](#Script)  
**Overrides**: [<code>retrieveAsTemplate</code>](#MetadataType+retrieveAsTemplate)  
**Returns**: <code>Promise.&lt;{metadata:ScriptMap, type:string}&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="Script+postRetrieveTasks"></a>

### script.postRetrieveTasks(metadata, [_], [isTemplating]) ⇒ [<code>CodeExtractItem</code>](#CodeExtractItem)
manages post retrieve steps

**Kind**: instance method of [<code>Script</code>](#Script)  
**Overrides**: [<code>postRetrieveTasks</code>](#MetadataType+postRetrieveTasks)  
**Returns**: [<code>CodeExtractItem</code>](#CodeExtractItem) - Array with one metadata object and one ssjs string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>ScriptItem</code> | a single script |
| [_] | <code>string</code> | unused |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="Script+update"></a>

### script.update(script) ⇒ <code>Promise</code>
Updates a single Script

**Kind**: instance method of [<code>Script</code>](#Script)  
**Overrides**: [<code>update</code>](#MetadataType+update)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| script | <code>Object</code> | a single Script |

<a name="Script+create"></a>

### script.create(script) ⇒ <code>Promise</code>
Creates a single Script

**Kind**: instance method of [<code>Script</code>](#Script)  
**Overrides**: [<code>create</code>](#MetadataType+create)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| script | <code>Object</code> | a single Script |

<a name="Script+_mergeCode"></a>

### script.\_mergeCode(metadata, deployDir, [templateName]) ⇒ <code>Promise.&lt;String&gt;</code>
helper for this.preDeployTasks() that loads extracted code content back into JSON

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise.&lt;String&gt;</code> - content for metadata.script  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>ScriptItem</code> | a single asset definition |
| deployDir | <code>string</code> | directory of deploy files |
| [templateName] | <code>string</code> | name of the template used to built defintion (prior applying templating) |

<a name="Script+preDeployTasks"></a>

### script.preDeployTasks(metadata, dir) ⇒ <code>ScriptItem</code>
prepares a Script for deployment

**Kind**: instance method of [<code>Script</code>](#Script)  
**Overrides**: [<code>preDeployTasks</code>](#MetadataType+preDeployTasks)  
**Returns**: <code>ScriptItem</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>ScriptItem</code> | a single script activity definition |
| dir | <code>string</code> | directory of deploy files |

<a name="Script+buildDefinitionForExtracts"></a>

### script.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise</code>
helper for buildDefinition
handles extracted code if any are found for complex types

**Kind**: instance method of [<code>Script</code>](#Script)  
**Overrides**: [<code>buildDefinitionForExtracts</code>](#MetadataType+buildDefinitionForExtracts)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> \| <code>Array.&lt;string&gt;</code> | (List of) Directory where built definitions will be saved |
| metadata | <code>ScriptItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="Script+parseMetadata"></a>

### script.parseMetadata(metadata) ⇒ [<code>CodeExtractItem</code>](#CodeExtractItem)
Splits the script metadata into two parts and parses in a standard manner

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: [<code>CodeExtractItem</code>](#CodeExtractItem) - a single item with code parts extracted  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>ScriptItem</code> | a single script activity definition |

<a name="MetadataType+getJsonFromFS"></a>

### script.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### script.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### script.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### script.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>Script</code>](#Script)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+overrideKeyWithName"></a>

### script.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>Script</code>](#Script)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### script.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+upsert"></a>

### script.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### script.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### script.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### script.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### script.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### script.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### script.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### script.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### script.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>Script</code>](#Script)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### script.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>Script</code>](#Script)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### script.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>Script</code>](#Script)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### script.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>Script</code>](#Script)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### script.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>Script</code>](#Script)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### script.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### script.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### script.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+findSubType"></a>

### script.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### script.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### script.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### script.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### script.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>Script</code>](#Script)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### script.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### script.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### script.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### script.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>Script</code>](#Script)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="SetDefinition"></a>

## SetDefinition ⇐ [<code>MetadataType</code>](#MetadataType)
SetDefinition MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [SetDefinition](#SetDefinition) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#SetDefinition+retrieve) ⇒ <code>Promise</code>
    * [.retrieveForCache()](#SetDefinition+retrieveForCache) ⇒ <code>Promise</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.postRetrieveTasks(metadata, targetDir, [isTemplating])](#MetadataType+postRetrieveTasks) ⇒ <code>Util.MetadataTypeItem</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
    * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
    * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="SetDefinition+retrieve"></a>

### setDefinition.retrieve(retrieveDir) ⇒ <code>Promise</code>
Retrieves Metadata of schema set Definitions.

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="SetDefinition+retrieveForCache"></a>

### setDefinition.retrieveForCache() ⇒ <code>Promise</code>
Retrieves Metadata of schema set definitions for caching.

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Overrides**: [<code>retrieveForCache</code>](#MetadataType+retrieveForCache)  
**Returns**: <code>Promise</code> - Promise  
<a name="MetadataType+getJsonFromFS"></a>

### setDefinition.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### setDefinition.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### setDefinition.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### setDefinition.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+postRetrieveTasks"></a>

### setDefinition.postRetrieveTasks(metadata, targetDir, [isTemplating]) ⇒ <code>Util.MetadataTypeItem</code>
Gets executed after retreive of metadata type

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Util.MetadataTypeItem</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| targetDir | <code>string</code> | folder where retrieves should be saved |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="MetadataType+overrideKeyWithName"></a>

### setDefinition.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### setDefinition.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### setDefinition.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### setDefinition.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### setDefinition.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### setDefinition.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### setDefinition.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### setDefinition.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### setDefinition.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### setDefinition.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### setDefinition.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### setDefinition.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### setDefinition.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### setDefinition.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### setDefinition.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### setDefinition.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### setDefinition.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### setDefinition.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### setDefinition.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### setDefinition.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### setDefinition.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### setDefinition.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### setDefinition.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### setDefinition.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### setDefinition.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### setDefinition.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### setDefinition.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### setDefinition.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### setDefinition.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### setDefinition.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### setDefinition.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### setDefinition.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>SetDefinition</code>](#SetDefinition)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="TriggeredSendDefinition"></a>

## TriggeredSendDefinition ⇐ [<code>MetadataType</code>](#MetadataType)
MessageSendActivity MetadataType

**Kind**: global class  
**Extends**: [<code>MetadataType</code>](#MetadataType)  

* [TriggeredSendDefinition](#TriggeredSendDefinition) ⇐ [<code>MetadataType</code>](#MetadataType)
    * [.retrieve(retrieveDir)](#TriggeredSendDefinition+retrieve) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.create(metadata)](#TriggeredSendDefinition+create) ⇒ <code>Promise</code>
    * [.update(metadata)](#TriggeredSendDefinition+update) ⇒ <code>Promise</code>
    * [.deleteByKey(customerKey)](#TriggeredSendDefinition+deleteByKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.postRetrieveTasks(metadata)](#TriggeredSendDefinition+postRetrieveTasks) ⇒ <code>Array.&lt;Object&gt;</code>
    * [.parseMetadata(metadata)](#TriggeredSendDefinition+parseMetadata) ⇒ <code>Array</code>
    * [.preDeployTasks(metadata)](#TriggeredSendDefinition+preDeployTasks) ⇒ <code>Object</code>
    * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
    * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
    * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
    * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
    * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveForCache([subType])](#MetadataType+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
    * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
    * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
    * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
    * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
    * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
    * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
    * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
    * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
    * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
    * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
    * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
    * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
    * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
    * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
    * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
    * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
    * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
    * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
    * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>

<a name="TriggeredSendDefinition+retrieve"></a>

### triggeredSendDefinition.retrieve(retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves SOAP based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Overrides**: [<code>retrieve</code>](#MetadataType+retrieve)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>String</code> | Directory where retrieved metadata directory will be saved |

<a name="TriggeredSendDefinition+create"></a>

### triggeredSendDefinition.create(metadata) ⇒ <code>Promise</code>
Create a single TSD.

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Overrides**: [<code>create</code>](#MetadataType+create)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | single metadata entry |

<a name="TriggeredSendDefinition+update"></a>

### triggeredSendDefinition.update(metadata) ⇒ <code>Promise</code>
Updates a single TSD.

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Overrides**: [<code>update</code>](#MetadataType+update)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | single metadata entry |

<a name="TriggeredSendDefinition+deleteByKey"></a>

### triggeredSendDefinition.deleteByKey(customerKey) ⇒ <code>Promise.&lt;boolean&gt;</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Overrides**: [<code>deleteByKey</code>](#MetadataType+deleteByKey)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="TriggeredSendDefinition+postRetrieveTasks"></a>

### triggeredSendDefinition.postRetrieveTasks(metadata) ⇒ <code>Array.&lt;Object&gt;</code>
manages post retrieve steps

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Overrides**: [<code>postRetrieveTasks</code>](#MetadataType+postRetrieveTasks)  
**Returns**: <code>Array.&lt;Object&gt;</code> - Array with one metadata object and one query string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single query |

<a name="TriggeredSendDefinition+parseMetadata"></a>

### triggeredSendDefinition.parseMetadata(metadata) ⇒ <code>Array</code>
parses retrieved Metadata before saving

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Array</code> - Array with one metadata object and one sql string  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | a single query activity definition |

<a name="TriggeredSendDefinition+preDeployTasks"></a>

### triggeredSendDefinition.preDeployTasks(metadata) ⇒ <code>Object</code>
prepares a TSD for deployment

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Overrides**: [<code>preDeployTasks</code>](#MetadataType+preDeployTasks)  
**Returns**: <code>Object</code> - metadata object  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Object</code> | of a single TSD |

<a name="MetadataType+getJsonFromFS"></a>

### triggeredSendDefinition.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### triggeredSendDefinition.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### triggeredSendDefinition.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### triggeredSendDefinition.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+overrideKeyWithName"></a>

### triggeredSendDefinition.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieveChangelog"></a>

### triggeredSendDefinition.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveForCache"></a>

### triggeredSendDefinition.retrieveForCache([subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### triggeredSendDefinition.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+upsert"></a>

### triggeredSendDefinition.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### triggeredSendDefinition.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### triggeredSendDefinition.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### triggeredSendDefinition.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### triggeredSendDefinition.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### triggeredSendDefinition.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### triggeredSendDefinition.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### triggeredSendDefinition.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### triggeredSendDefinition.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### triggeredSendDefinition.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### triggeredSendDefinition.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### triggeredSendDefinition.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### triggeredSendDefinition.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### triggeredSendDefinition.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### triggeredSendDefinition.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### triggeredSendDefinition.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### triggeredSendDefinition.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### triggeredSendDefinition.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### triggeredSendDefinition.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### triggeredSendDefinition.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### triggeredSendDefinition.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### triggeredSendDefinition.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+postDeleteTasks"></a>

### triggeredSendDefinition.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### triggeredSendDefinition.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### triggeredSendDefinition.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>TriggeredSendDefinition</code>](#TriggeredSendDefinition)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="Retriever"></a>

## Retriever
Retrieves metadata from a business unit and saves it to the local filesystem.

**Kind**: global class  

* [Retriever](#Retriever)
    * [new Retriever(properties, buObject)](#new_Retriever_new)
    * [.retrieve(metadataTypes, [name], [templateVariables], [changelogOnly])](#Retriever+retrieve) ⇒ <code>Promise.&lt;Util.MultiMetadataTypeList&gt;</code>

<a name="new_Retriever_new"></a>

### new Retriever(properties, buObject)
Creates a Retriever, uses v2 auth if v2AuthOptions are passed.


| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | General configuration to be used in retrieve |
| properties.directories | <code>Object</code> | Directories to be used when interacting with FS |
| buObject | <code>auth.BuObject</code> | details of business unit in processing |

<a name="Retriever+retrieve"></a>

### retriever.retrieve(metadataTypes, [name], [templateVariables], [changelogOnly]) ⇒ <code>Promise.&lt;Util.MultiMetadataTypeList&gt;</code>
Retrieve metadata of specified types into local file system and Retriever.metadata

**Kind**: instance method of [<code>Retriever</code>](#Retriever)  
**Returns**: <code>Promise.&lt;Util.MultiMetadataTypeList&gt;</code> - Promise of a list of retrieved items grouped by type {automation:[...], query:[...]}  

| Param | Type | Description |
| --- | --- | --- |
| metadataTypes | <code>Array.&lt;String&gt;</code> | String list of metadata types to retrieve |
| [name] | <code>String</code> | name of Metadata to retrieve (in case of templating) |
| [templateVariables] | <code>Object</code> | Object of values which can be replaced (in case of templating) |
| [changelogOnly] | <code>boolean</code> | skip saving, only create json in memory |

<a name="Util"></a>

## Util
CLI entry for SFMC DevTools

**Kind**: global constant  

* [Util](#Util)
    * [.logger](#Util.logger)
    * [.isTrue(attrValue)](#Util.isTrue) ⇒ <code>boolean</code>
    * [.isFalse(attrValue)](#Util.isFalse) ⇒ <code>boolean</code>
    * [.getDefaultProperties()](#Util.getDefaultProperties) ⇒ <code>object</code>
    * [.getRetrieveTypeChoices()](#Util.getRetrieveTypeChoices) ⇒ <code>Array.&lt;string&gt;</code>
    * [.checkProperties(properties, [silent])](#Util.checkProperties) ⇒ <code>Promise.&lt;(boolean\|Array.&lt;String&gt;)&gt;</code>
    * [.metadataLogger(level, type, method, payload, [source])](#Util.metadataLogger) ⇒ <code>void</code>
    * [.replaceByObject(str, obj)](#Util.replaceByObject) ⇒ <code>String</code> \| <code>Object</code>
    * [.inverseGet(objs, val)](#Util.inverseGet) ⇒ <code>String</code>
    * [.getMetadataHierachy(metadataTypes)](#Util.getMetadataHierachy) ⇒ <code>Array.&lt;String&gt;</code>
    * [.resolveObjPath(path, obj)](#Util.resolveObjPath) ⇒ <code>any</code>
    * [.execSync(cmd, [args])](#Util.execSync) ⇒ <code>undefined</code>
    * [.templateSearchResult(results, keyToSearch, searchValue)](#Util.templateSearchResult) ⇒ <code>MetadataTypeItem</code>
    * [.setLoggingLevel(argv)](#Util.setLoggingLevel) ⇒ <code>void</code>

<a name="Util.logger"></a>

### Util.logger
Logger that creates timestamped log file in 'logs/' directory

**Kind**: static property of [<code>Util</code>](#Util)  
<a name="Util.isTrue"></a>

### Util.isTrue(attrValue) ⇒ <code>boolean</code>
SFMC accepts multiple true values for Boolean attributes for which we are checking here

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - attribute value == true ? true : false  

| Param | Type | Description |
| --- | --- | --- |
| attrValue | <code>\*</code> | value |

<a name="Util.isFalse"></a>

### Util.isFalse(attrValue) ⇒ <code>boolean</code>
SFMC accepts multiple false values for Boolean attributes for which we are checking here

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - attribute value == false ? true : false  

| Param | Type | Description |
| --- | --- | --- |
| attrValue | <code>\*</code> | value |

<a name="Util.getDefaultProperties"></a>

### Util.getDefaultProperties() ⇒ <code>object</code>
defines how the properties.json should look like
used for creating a template and for checking if variables are set

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>object</code> - default properties  
<a name="Util.getRetrieveTypeChoices"></a>

### Util.getRetrieveTypeChoices() ⇒ <code>Array.&lt;string&gt;</code>
helper for getDefaultProperties()

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Array.&lt;string&gt;</code> - type choices  
<a name="Util.checkProperties"></a>

### Util.checkProperties(properties, [silent]) ⇒ <code>Promise.&lt;(boolean\|Array.&lt;String&gt;)&gt;</code>
check if the config file is correctly formatted and has values

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Promise.&lt;(boolean\|Array.&lt;String&gt;)&gt;</code> - file structure ok OR list of fields to be fixed  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>object</code> | javascript object in .mcdevrc.json |
| [silent] | <code>boolean</code> | set to true for internal use w/o cli output |

<a name="Util.metadataLogger"></a>

### Util.metadataLogger(level, type, method, payload, [source]) ⇒ <code>void</code>
Logger helper for Metadata functions

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| level | <code>String</code> | of log (error, info, warn) |
| type | <code>String</code> | of metadata being referenced |
| method | <code>String</code> | name which log was called from |
| payload | <code>\*</code> | generic object which details the error |
| [source] | <code>String</code> | key/id of metadata which relates to error |

<a name="Util.replaceByObject"></a>

### Util.replaceByObject(str, obj) ⇒ <code>String</code> \| <code>Object</code>
replaces values in a JSON object string, based on a series of
key-value pairs (obj)

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>String</code> \| <code>Object</code> - replaced version of str  

| Param | Type | Description |
| --- | --- | --- |
| str | <code>String</code> \| <code>Object</code> | JSON object or its stringified version, which has values to be replaced |
| obj | <code>TemplateMap</code> | key value object which contains keys to be replaced and values to be replaced with |

<a name="Util.inverseGet"></a>

### Util.inverseGet(objs, val) ⇒ <code>String</code>
get key of an object based on the first matching value

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>String</code> - key  

| Param | Type | Description |
| --- | --- | --- |
| objs | <code>Object</code> | object of objects to be searched |
| val | <code>String</code> | value to be searched for |

<a name="Util.getMetadataHierachy"></a>

### Util.getMetadataHierachy(metadataTypes) ⇒ <code>Array.&lt;String&gt;</code>
Returns Order in which metadata needs to be retrieved/deployed

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Array.&lt;String&gt;</code> - retrieve/deploy order as array  

| Param | Type | Description |
| --- | --- | --- |
| metadataTypes | <code>Array.&lt;String&gt;</code> | which should be retrieved/deployed |

<a name="Util.resolveObjPath"></a>

### Util.resolveObjPath(path, obj) ⇒ <code>any</code>
let's you dynamically walk down an object and get a value

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>any</code> - value of obj.path  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>String</code> | 'fieldA.fieldB.fieldC' |
| obj | <code>Object</code> | some parent object |

<a name="Util.execSync"></a>

### Util.execSync(cmd, [args]) ⇒ <code>undefined</code>
helper to run other commands as if run manually by user

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| cmd | <code>string</code> | to be executed command |
| [args] | <code>Array.&lt;string&gt;</code> | list of arguments |

<a name="Util.templateSearchResult"></a>

### Util.templateSearchResult(results, keyToSearch, searchValue) ⇒ <code>MetadataTypeItem</code>
standardize check to ensure only one result is returned from template search

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>MetadataTypeItem</code> - metadata to be used in building template  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Array.&lt;MetadataTypeItem&gt;</code> | array of metadata |
| keyToSearch | <code>string</code> | the field which contains the searched value |
| searchValue | <code>string</code> | the value which is being looked for |

<a name="Util.setLoggingLevel"></a>

### Util.setLoggingLevel(argv) ⇒ <code>void</code>
configures what is displayed in the console

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| argv | <code>Object</code> | list of command line parameters given by user |
| [argv.silent] | <code>boolean</code> | only errors printed to CLI |
| [argv.verbose] | <code>boolean</code> | chatty user CLI output |
| [argv.debug] | <code>boolean</code> | enables developer output & features |

<a name="MetadataTypeDefinitions"></a>

## MetadataTypeDefinitions
Provides access to all metadataType classes

**Kind**: global constant  
<a name="MetadataTypeInfo"></a>

## MetadataTypeInfo
Provides access to all metadataType classes

**Kind**: global constant  
<a name="mcdev"></a>

## mcdev
sample file on how to retrieve a simple changelog to use in GUIs or automated processing of any kind

**Kind**: global constant  
**Example**  
```js
[{
    name: 'deName',
    key: 'deKey',
    t: 'dataExtension',
    cd: '2020-05-06T00:16:00.737',
    cb: 'name of creator',
    ld: '2020-05-06T00:16:00.737',
    lb: 'name of lastmodified'
  }]
```
<a name="SDK"></a>

## SDK : [<code>SDK</code>](#SDK)
**Kind**: global constant  
<a name="BusinessUnit"></a>

## BusinessUnit
Helper that handles retrieval of BU info

**Kind**: global constant  
<a name="BusinessUnit.refreshBUProperties"></a>

### BusinessUnit.refreshBUProperties(properties, credentialsName) ⇒ <code>Promise.&lt;boolean&gt;</code>
Refreshes BU names and ID's from MC instance

**Kind**: static method of [<code>BusinessUnit</code>](#BusinessUnit)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - success of refresh  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>object</code> | current properties that have to be refreshed |
| credentialsName | <code>string</code> | identifying name of the installed package / project |

<a name="Cli"></a>

## Cli
CLI helper class

**Kind**: global constant  

* [Cli](#Cli)
    * [.initMcdevConfig([skipInteraction])](#Cli.initMcdevConfig) ⇒ <code>Promise.&lt;boolean&gt;</code>
    * [.addExtraCredential(properties, [skipInteraction])](#Cli.addExtraCredential) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.updateCredential(properties, credName, [skipInteraction])](#Cli.updateCredential) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [.getBusinessUnitObject(properties, target, [isCredentialOnly], [allowAll])](#Cli.getBusinessUnitObject) ⇒ <code>Promise.&lt;Util.BuObject&gt;</code>
    * [._selectBU(properties, [credential], [isCredentialOnly], [allowAll])](#Cli._selectBU) ⇒ <code>Promise.&lt;Array&gt;</code>
    * [._setCredential(properties, [credName], [skipInteraction])](#Cli._setCredential) ⇒ <code>Promise.&lt;(boolean\|String)&gt;</code>
    * [._askCredentials(properties, [credName])](#Cli._askCredentials) ⇒ <code>Promise.&lt;Object&gt;</code>
    * [.selectTypes(properties, [setTypesArr])](#Cli.selectTypes) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._summarizeSubtypes(responses, type)](#Cli._summarizeSubtypes) ⇒ <code>void</code>
    * [.explainTypes()](#Cli.explainTypes) ⇒ <code>void</code>

<a name="Cli.initMcdevConfig"></a>

### Cli.initMcdevConfig([skipInteraction]) ⇒ <code>Promise.&lt;boolean&gt;</code>
used when initially setting up a project.
loads default config and adds first credential

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - success of init  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Object</code> | signals what to insert automatically for things usually asked via wizard |
| skipInteraction.client_id | <code>String</code> | client id of installed package |
| skipInteraction.client_secret | <code>String</code> | client secret of installed package |
| skipInteraction.auth_url | <code>String</code> | auth_url of installed package |
| skipInteraction.eid | <code>String</code> | MID of the Parent Business Unit |
| skipInteraction.credentialsName | <code>String</code> | how you would like the credential to be named |

<a name="Cli.addExtraCredential"></a>

### Cli.addExtraCredential(properties, [skipInteraction]) ⇒ <code>Promise.&lt;void&gt;</code>
Extends template file for properties.json

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | config file's json |
| properties.credentials | <code>Object</code> | list of existing credentials |
| [skipInteraction] | <code>Object</code> | signals what to insert automatically for things usually asked via wizard |
| skipInteraction.client_id | <code>String</code> | client id of installed package |
| skipInteraction.client_secret | <code>String</code> | client secret of installed package |
| skipInteraction.auth_url | <code>String</code> | auth_url of installed package |
| skipInteraction.eid | <code>String</code> | MID of the Parent Business Unit |
| skipInteraction.credentialsName | <code>String</code> | how you would like the credential to be named |

<a name="Cli.updateCredential"></a>

### Cli.updateCredential(properties, credName, [skipInteraction]) ⇒ <code>Promise.&lt;Boolean&gt;</code>
Extends template file for properties.json
update credentials

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - success of update  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>object</code> | config file's json |
| credName | <code>string</code> | name of credential that needs updating |
| [skipInteraction] | <code>Object</code> | signals what to insert automatically for things usually asked via wizard |
| skipInteraction.client_id | <code>String</code> | client id of installed package |
| skipInteraction.client_secret | <code>String</code> | client secret of installed package |
| skipInteraction.auth_url | <code>String</code> | auth_url of installed package |
| skipInteraction.eid | <code>String</code> | MID of the Parent Business Unit |
| skipInteraction.credentialsName | <code>String</code> | how you would like the credential to be named |

<a name="Cli.getBusinessUnitObject"></a>

### Cli.getBusinessUnitObject(properties, target, [isCredentialOnly], [allowAll]) ⇒ <code>Promise.&lt;Util.BuObject&gt;</code>
Returns Object with parameters required for accessing API

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;Util.BuObject&gt;</code> - credential to be used for Business Unit  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | object of all configuration including credentials |
| target | <code>String</code> | code of BU to use |
| [isCredentialOnly] | <code>boolean</code> \| <code>string</code> | true:don't ask for BU | string: name of BU |
| [allowAll] | <code>boolean</code> | Offer ALL as option in BU selection |

<a name="Cli._selectBU"></a>

### Cli.\_selectBU(properties, [credential], [isCredentialOnly], [allowAll]) ⇒ <code>Promise.&lt;Array&gt;</code>
helps select the right credential in case of bad initial input

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;Array&gt;</code> - selected credential/BU combo  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>object</code> | config file's json |
| [credential] | <code>string</code> | name of valid credential |
| [isCredentialOnly] | <code>boolean</code> | don't ask for BU if true |
| [allowAll] | <code>boolean</code> | Offer ALL as option in BU selection |

<a name="Cli._setCredential"></a>

### Cli.\_setCredential(properties, [credName], [skipInteraction]) ⇒ <code>Promise.&lt;(boolean\|String)&gt;</code>
helper around _askCredentials

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;(boolean\|String)&gt;</code> - success of refresh or credential name  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>object</code> | from config file |
| [credName] | <code>string</code> | name of credential that needs updating |
| [skipInteraction] | <code>Object</code> | signals what to insert automatically for things usually asked via wizard |
| skipInteraction.client_id | <code>String</code> | client id of installed package |
| skipInteraction.client_secret | <code>String</code> | client id of installed package |
| skipInteraction.auth_url | <code>String</code> | client id of installed package |
| skipInteraction.credentialsName | <code>String</code> | how you would like the credential to be named |

<a name="Cli._askCredentials"></a>

### Cli.\_askCredentials(properties, [credName]) ⇒ <code>Promise.&lt;Object&gt;</code>
helper for addExtraCredential()

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - credential info  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | from config file |
| [credName] | <code>string</code> | name of credential that needs updating |

<a name="Cli.selectTypes"></a>

### Cli.selectTypes(properties, [setTypesArr]) ⇒ <code>Promise.&lt;void&gt;</code>
allows updating the metadata types that shall be retrieved

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>object</code> | config file's json |
| properties.metaDataTypes | <code>object</code> | - |
| properties.metaDataTypes.retrieve | <code>Array.&lt;String&gt;</code> | list of currently retrieved types |
| [setTypesArr] | <code>Array.&lt;String&gt;</code> | skip user prompt and overwrite with this list if given |

<a name="Cli._summarizeSubtypes"></a>

### Cli.\_summarizeSubtypes(responses, type) ⇒ <code>void</code>
helper for this.selectTypes() that converts subtypes back to main type if all and only defaults were selected
this keeps the config automatically upgradable when we add new subtypes or change what is selected by default

**Kind**: static method of [<code>Cli</code>](#Cli)  

| Param | Type | Description |
| --- | --- | --- |
| responses | <code>Object</code> | wrapper object for respones |
| responses.selectedTypes | <code>Array.&lt;String&gt;</code> | what types the user selected |
| type | <code>String</code> | metadata type |

<a name="Cli.explainTypes"></a>

### Cli.explainTypes() ⇒ <code>void</code>
shows metadata type descriptions

**Kind**: static method of [<code>Cli</code>](#Cli)  
**Returns**: <code>void</code> - -  
<a name="DevOps"></a>

## DevOps
DevOps helper class

**Kind**: global constant  

* [DevOps](#DevOps)
    * [.createDeltaPkg(properties, [range], [saveToDeployDir], [filterPaths])](#DevOps.createDeltaPkg) ⇒ <code>Promise.&lt;Array.&lt;Object&gt;&gt;</code>
    * [.document(directory, jsonReport)](#DevOps.document) ⇒ <code>void</code>

<a name="DevOps.createDeltaPkg"></a>

### DevOps.createDeltaPkg(properties, [range], [saveToDeployDir], [filterPaths]) ⇒ <code>Promise.&lt;Array.&lt;Object&gt;&gt;</code>
Extracts the delta between a commit and the current state for deployment.
Interactive commit selection if no commits are passed.

**Kind**: static method of [<code>DevOps</code>](#DevOps)  
**Returns**: <code>Promise.&lt;Array.&lt;Object&gt;&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | central properties object |
| [range] | <code>String</code> | git commit range |
| [saveToDeployDir] | <code>boolean</code> | if true, copy metadata changes into deploy directory |
| [filterPaths] | <code>String</code> | filter file paths that start with any specified path (comma separated) |

<a name="DevOps.document"></a>

### DevOps.document(directory, jsonReport) ⇒ <code>void</code>
create markdown file for deployment listing

**Kind**: static method of [<code>DevOps</code>](#DevOps)  

| Param | Type | Description |
| --- | --- | --- |
| directory | <code>String</code> | - |
| jsonReport | <code>Object</code> | - |

<a name="File"></a>

## File
File extends fs-extra. It adds logger and util methods for file handling

**Kind**: global constant  

* [File](#File)
    * [.copyFile(from, to)](#File.copyFile) ⇒ <code>Object</code>
    * [.filterIllegalPathChars(path)](#File.filterIllegalPathChars) ⇒ <code>String</code>
    * [.filterIllegalFilenames(filename)](#File.filterIllegalFilenames) ⇒ <code>String</code>
    * [.reverseFilterIllegalFilenames(filename)](#File.reverseFilterIllegalFilenames) ⇒ <code>String</code>
    * [.normalizePath(denormalizedPath)](#File.normalizePath) ⇒ <code>String</code>
    * [.writeJSONToFile(directory, filename, content)](#File.writeJSONToFile) ⇒ <code>Promise</code>
    * [.writePrettyToFile(directory, filename, filetype, content, [templateVariables])](#File.writePrettyToFile) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [._beautify_sql(content)](#File._beautify_sql) ⇒ <code>String</code>
    * [._beautify_prettier(directory, filename, filetype, content)](#File._beautify_prettier) ⇒ <code>String</code>
    * [.writeToFile(directory, filename, filetype, content, [encoding])](#File.writeToFile) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [.readJSONFile(directory, filename, sync, cleanPath)](#File.readJSONFile) ⇒ <code>Promise</code> \| <code>Object</code>
    * [.readFile(directory, filename, filetype, [encoding])](#File.readFile) ⇒ <code>Promise.&lt;String&gt;</code>
    * [.readDirectories(directory, depth, [includeStem], [_stemLength])](#File.readDirectories) ⇒ <code>Promise.&lt;Array.&lt;String&gt;&gt;</code>
    * [.readDirectoriesSync(directory, [depth], [includeStem], [_stemLength])](#File.readDirectoriesSync) ⇒ <code>Array.&lt;String&gt;</code>
    * [.loadConfigFile([silent])](#File.loadConfigFile) ⇒ <code>Object</code>
    * [.saveConfigFile(properties)](#File.saveConfigFile) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.initPrettier([filetype])](#File.initPrettier) ⇒ <code>Promise.&lt;Boolean&gt;</code>

<a name="File.copyFile"></a>

### File.copyFile(from, to) ⇒ <code>Object</code>
copies a file from one path to another

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Object</code> - - results object  

| Param | Type | Description |
| --- | --- | --- |
| from | <code>String</code> | full filepath including name of existing file |
| to | <code>String</code> | full filepath including name where file should go |

<a name="File.filterIllegalPathChars"></a>

### File.filterIllegalPathChars(path) ⇒ <code>String</code>
makes sure Windows accepts path names

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>String</code> - - corrected string  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>String</code> | filename or path |

<a name="File.filterIllegalFilenames"></a>

### File.filterIllegalFilenames(filename) ⇒ <code>String</code>
makes sure Windows accepts file names

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>String</code> - - corrected string  

| Param | Type | Description |
| --- | --- | --- |
| filename | <code>String</code> | filename or path |

<a name="File.reverseFilterIllegalFilenames"></a>

### File.reverseFilterIllegalFilenames(filename) ⇒ <code>String</code>
makes sure Windows accepts file names

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>String</code> - - corrected string  

| Param | Type | Description |
| --- | --- | --- |
| filename | <code>String</code> | filename or path |

<a name="File.normalizePath"></a>

### File.normalizePath(denormalizedPath) ⇒ <code>String</code>
Takes various types of path strings and formats into a platform specific path

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>String</code> - Path strings  

| Param | Type | Description |
| --- | --- | --- |
| denormalizedPath | <code>string</code> \| <code>Array.&lt;string&gt;</code> | directory the file will be written to |

<a name="File.writeJSONToFile"></a>

### File.writeJSONToFile(directory, filename, content) ⇒ <code>Promise</code>
Saves json content to a file in the local file system. Will create the parent directory if it does not exist

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| directory | <code>string</code> \| <code>Array.&lt;string&gt;</code> | directory the file will be written to |
| filename | <code>String</code> | name of the file without '.json' ending |
| content | <code>Object</code> | filecontent |

<a name="File.writePrettyToFile"></a>

### File.writePrettyToFile(directory, filename, filetype, content, [templateVariables]) ⇒ <code>Promise.&lt;Boolean&gt;</code>
Saves beautified files in the local file system. Will create the parent directory if it does not exist
! Important: run 'await File.initPrettier()' in your MetadataType.retrieve() once before hitting this

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| directory | <code>string</code> \| <code>Array.&lt;string&gt;</code> | directory the file will be written to |
| filename | <code>String</code> | name of the file without suffix |
| filetype | <code>String</code> | filetype ie. JSON or SSJS |
| content | <code>String</code> | filecontent |
| [templateVariables] | <code>Object</code> | templating variables to be replaced in the metadata |

<a name="File._beautify_sql"></a>

### File.\_beautify\_sql(content) ⇒ <code>String</code>
helper for writePrettyToFile, applying sql formatting onto given stringified content

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>String</code> - original string on error; formatted string on success  

| Param | Type | Description |
| --- | --- | --- |
| content | <code>String</code> | filecontent |

<a name="File._beautify_prettier"></a>

### File.\_beautify\_prettier(directory, filename, filetype, content) ⇒ <code>String</code>
helper for writePrettyToFile, applying prettier onto given stringified content
! Important: run 'await File.initPrettier()' in your MetadataType.retrieve() once before hitting this

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>String</code> - original string on error; formatted string on success  

| Param | Type | Description |
| --- | --- | --- |
| directory | <code>string</code> \| <code>Array.&lt;string&gt;</code> | directory the file will be written to |
| filename | <code>String</code> | name of the file without suffix |
| filetype | <code>String</code> | filetype ie. JSON or SSJS |
| content | <code>String</code> | filecontent |

<a name="File.writeToFile"></a>

### File.writeToFile(directory, filename, filetype, content, [encoding]) ⇒ <code>Promise.&lt;Boolean&gt;</code>
Saves text content to a file in the local file system. Will create the parent directory if it does not exist

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| directory | <code>string</code> \| <code>Array.&lt;string&gt;</code> | directory the file will be written to |
| filename | <code>String</code> | name of the file without '.json' ending |
| filetype | <code>String</code> | filetype suffix |
| content | <code>String</code> | filecontent |
| [encoding] | <code>Object</code> | added for certain file types (like images) |

<a name="File.readJSONFile"></a>

### File.readJSONFile(directory, filename, sync, cleanPath) ⇒ <code>Promise</code> \| <code>Object</code>
Saves json content to a file in the local file system. Will create the parent directory if it does not exist

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Promise</code> \| <code>Object</code> - Promise or JSON object depending on if async or not  

| Param | Type | Description |
| --- | --- | --- |
| directory | <code>String</code> \| <code>Array.&lt;String&gt;</code> | directory where the file is stored |
| filename | <code>String</code> | name of the file without '.json' ending |
| sync | <code>Boolean</code> | should execute sync (default is async) |
| cleanPath | <code>Boolean</code> | should execute sync (default is true) |

<a name="File.readFile"></a>

### File.readFile(directory, filename, filetype, [encoding]) ⇒ <code>Promise.&lt;String&gt;</code>
reads file from local file system.

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Promise.&lt;String&gt;</code> - file contents  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| directory | <code>String</code> \| <code>Array.&lt;String&gt;</code> |  | directory where the file is stored |
| filename | <code>String</code> |  | name of the file without '.json' ending |
| filetype | <code>String</code> |  | filetype suffix |
| [encoding] | <code>String</code> | <code>&#x27;utf8&#x27;</code> | read file with encoding (defaults to utf-8) |

<a name="File.readDirectories"></a>

### File.readDirectories(directory, depth, [includeStem], [_stemLength]) ⇒ <code>Promise.&lt;Array.&lt;String&gt;&gt;</code>
reads directories to a specific depth returning an array
of file paths to be iterated over

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Promise.&lt;Array.&lt;String&gt;&gt;</code> - array of fully defined file paths  

| Param | Type | Description |
| --- | --- | --- |
| directory | <code>String</code> | directory to checkin |
| depth | <code>Number</code> | how many levels to check (1 base) |
| [includeStem] | <code>Boolean</code> | include the parent directory in the response |
| [_stemLength] | <code>Number</code> | set recursively for subfolders. do not set manually! |

**Example**  
```js
['deploy/mcdev/bu1']
```
<a name="File.readDirectoriesSync"></a>

### File.readDirectoriesSync(directory, [depth], [includeStem], [_stemLength]) ⇒ <code>Array.&lt;String&gt;</code>
reads directories to a specific depth returning an array
of file paths to be iterated over using sync api (required in constructors)

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Array.&lt;String&gt;</code> - array of fully defined file paths  

| Param | Type | Description |
| --- | --- | --- |
| directory | <code>String</code> | directory to checkin |
| [depth] | <code>Number</code> | how many levels to check (1 base) |
| [includeStem] | <code>Boolean</code> | include the parent directory in the response |
| [_stemLength] | <code>Number</code> | set recursively for subfolders. do not set manually! |

**Example**  
```js
['deploy/mcdev/bu1']
```
<a name="File.loadConfigFile"></a>

### File.loadConfigFile([silent]) ⇒ <code>Object</code>
loads central properties from config file

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Object</code> - central properties object  

| Param | Type | Description |
| --- | --- | --- |
| [silent] | <code>Boolean</code> | omit throwing errors and print messages; assuming not silent if not set |

<a name="File.saveConfigFile"></a>

### File.saveConfigFile(properties) ⇒ <code>Promise.&lt;void&gt;</code>
helper that splits the config back into auth & config parts to save them separately

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | central properties object |

<a name="File.initPrettier"></a>

### File.initPrettier([filetype]) ⇒ <code>Promise.&lt;Boolean&gt;</code>
Initalises Prettier formatting lib async.

**Kind**: static method of [<code>File</code>](#File)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - success of config load  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [filetype] | <code>String</code> | <code>&#x27;html&#x27;</code> | filetype ie. JSON or SSJS |

<a name="Init"></a>

## Init
CLI helper class

**Kind**: global constant  

* [Init](#Init)
    * [.fixMcdevConfig(properties)](#Init.fixMcdevConfig) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [.createIdeConfigFiles()](#Init.createIdeConfigFiles) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [._updateLeaf(propertiersCur, defaultPropsCur, fieldName)](#Init._updateLeaf) ⇒ <code>void</code>
    * [._createIdeConfigFile(fileNameArr, [fileContent])](#Init._createIdeConfigFile) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [.initGitRepo([skipInteraction])](#Init.initGitRepo) ⇒ <code>Promise.&lt;{status:String, repoName:String}&gt;</code>
    * [.gitPush([skipInteraction])](#Init.gitPush) ⇒ <code>void</code>
    * [._addGitRemote([skipInteraction])](#Init._addGitRemote) ⇒ <code>String</code>
    * [._updateGitConfigUser([skipInteraction])](#Init._updateGitConfigUser) ⇒ <code>void</code>
    * [._getGitConfigUser()](#Init._getGitConfigUser) ⇒ <code>Promise.&lt;{&#x27;user.name&#x27;: String, &#x27;user.email&#x27;: String}&gt;</code>
    * [.initProject(properties, credentialsName, [skipInteraction])](#Init.initProject) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._downloadAllBUs(bu, gitStatus, [skipInteraction])](#Init._downloadAllBUs) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.upgradeProject(properties, [initial], [repoName])](#Init.upgradeProject) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [._getMissingCredentials(properties)](#Init._getMissingCredentials) ⇒ <code>Array.&lt;String&gt;</code>
    * [.installDependencies([repoName])](#Init.installDependencies) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [._getDefaultPackageJson([currentContent])](#Init._getDefaultPackageJson) ⇒ <code>Promise.&lt;{script: Object, author: String, license: String}&gt;</code>

<a name="Init.fixMcdevConfig"></a>

### Init.fixMcdevConfig(properties) ⇒ <code>Promise.&lt;Boolean&gt;</code>
helper method for this.upgradeProject that upgrades project config if needed

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - returns true if worked without errors  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | config file's json |

<a name="Init.createIdeConfigFiles"></a>

### Init.createIdeConfigFiles() ⇒ <code>Promise.&lt;Boolean&gt;</code>
handles creation/update of all config file from the boilerplate

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - status of config file creation  
<a name="Init._updateLeaf"></a>

### Init.\_updateLeaf(propertiersCur, defaultPropsCur, fieldName) ⇒ <code>void</code>
recursive helper for _fixMcdevConfig that adds missing settings

**Kind**: static method of [<code>Init</code>](#Init)  

| Param | Type | Description |
| --- | --- | --- |
| propertiersCur | <code>Object</code> | current sub-object of project settings |
| defaultPropsCur | <code>Object</code> | current sub-object of default settings |
| fieldName | <code>String</code> | dot-concatenated object-path that needs adding |

<a name="Init._createIdeConfigFile"></a>

### Init.\_createIdeConfigFile(fileNameArr, [fileContent]) ⇒ <code>Promise.&lt;Boolean&gt;</code>
handles creation/update of one config file from the boilerplate at a time

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - install successful or error occured  

| Param | Type | Description |
| --- | --- | --- |
| fileNameArr | <code>Array.&lt;String&gt;</code> | 0: path, 1: filename, 2: extension with dot |
| [fileContent] | <code>String</code> | in case we cannot copy files 1:1 this can be used to pass in content |

<a name="Init.initGitRepo"></a>

### Init.initGitRepo([skipInteraction]) ⇒ <code>Promise.&lt;{status:String, repoName:String}&gt;</code>
check if git repo exists and otherwise create one

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{status:String, repoName:String}&gt;</code> - success flag  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Object</code> | signals what to insert automatically for things usually asked via wizard |
| skipInteraction.gitRemoteUrl | <code>String</code> | URL of Git remote server |

<a name="Init.gitPush"></a>

### Init.gitPush([skipInteraction]) ⇒ <code>void</code>
offer to push the new repo straight to the server

**Kind**: static method of [<code>Init</code>](#Init)  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Boolean</code> \| <code>Object</code> | signals what to insert automatically for things usually asked via wizard |

<a name="Init._addGitRemote"></a>

### Init.\_addGitRemote([skipInteraction]) ⇒ <code>String</code>
offers to add the git remote origin

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>String</code> - repo name (optionally)  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Object</code> | signals what to insert automatically for things usually asked via wizard |
| skipInteraction.gitRemoteUrl | <code>String</code> | URL of Git remote server |

<a name="Init._updateGitConfigUser"></a>

### Init.\_updateGitConfigUser([skipInteraction]) ⇒ <code>void</code>
checks global config and ask to config the user info and then store it locally

**Kind**: static method of [<code>Init</code>](#Init)  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Object</code> \| <code>Boolean</code> | signals what to insert automatically for things usually asked via wizard |

<a name="Init._getGitConfigUser"></a>

### Init.\_getGitConfigUser() ⇒ <code>Promise.&lt;{&#x27;user.name&#x27;: String, &#x27;user.email&#x27;: String}&gt;</code>
retrieves the global user.name and user.email values

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{&#x27;user.name&#x27;: String, &#x27;user.email&#x27;: String}&gt;</code> - user.name and user.email  
<a name="Init.initProject"></a>

### Init.initProject(properties, credentialsName, [skipInteraction]) ⇒ <code>Promise.&lt;void&gt;</code>
Creates template file for properties.json

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | config file's json |
| credentialsName | <code>string</code> | identifying name of the installed package / project |
| [skipInteraction] | <code>Object</code> | signals what to insert automatically for things usually asked via wizard |
| skipInteraction.client_id | <code>String</code> | client id of installed package |
| skipInteraction.client_secret | <code>String</code> | client secret of installed package |
| skipInteraction.auth_url | <code>String</code> | auth_url of installed package |
| skipInteraction.eid | <code>String</code> | MID of the Parent Business Unit |
| skipInteraction.credentialsName | <code>String</code> | how you would like the credential to be named |
| skipInteraction.gitRemoteUrl | <code>String</code> | URL of Git remote server |

<a name="Init._downloadAllBUs"></a>

### Init.\_downloadAllBUs(bu, gitStatus, [skipInteraction]) ⇒ <code>Promise.&lt;void&gt;</code>
helper for this.initProject()

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| bu | <code>String</code> | cred/bu or cred/* or * |
| gitStatus | <code>String</code> | signals what state the git repo is in |
| [skipInteraction] | <code>Boolean</code> \| <code>Object</code> | signals what to insert automatically for things usually asked via wizard |

<a name="Init.upgradeProject"></a>

### Init.upgradeProject(properties, [initial], [repoName]) ⇒ <code>Promise.&lt;Boolean&gt;</code>
wrapper around npm dependency & configuration file setup

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - success flag  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | config file's json |
| [initial] | <code>Boolean</code> | print message if not part of initial setup |
| [repoName] | <code>String</code> | if git URL was provided earlier, the repo name was extracted to use it for npm init |

<a name="Init._getMissingCredentials"></a>

### Init.\_getMissingCredentials(properties) ⇒ <code>Array.&lt;String&gt;</code>
finds credentials that are set up in config but not in auth file

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Array.&lt;String&gt;</code> - list of credential names
TODO seems this is largely pointless - confirm with Joern  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>object</code> | javascript object in .mcdevrc.json |

<a name="Init.installDependencies"></a>

### Init.installDependencies([repoName]) ⇒ <code>Promise.&lt;Boolean&gt;</code>
initiates npm project and then
takes care of loading the pre-configured dependency list
from the boilerplate directory to them as dev-dependencies

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - install successful or error occured  

| Param | Type | Description |
| --- | --- | --- |
| [repoName] | <code>String</code> | if git URL was provided earlier, the repo name was extracted to use it for npm init |

<a name="Init._getDefaultPackageJson"></a>

### Init.\_getDefaultPackageJson([currentContent]) ⇒ <code>Promise.&lt;{script: Object, author: String, license: String}&gt;</code>
ensure we have certain default values in our config

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{script: Object, author: String, license: String}&gt;</code> - extended currentContent  

| Param | Type | Description |
| --- | --- | --- |
| [currentContent] | <code>Object</code> | what was read from existing package.json file |

<a name="Init"></a>

## Init
CLI helper class

**Kind**: global constant  

* [Init](#Init)
    * [.fixMcdevConfig(properties)](#Init.fixMcdevConfig) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [.createIdeConfigFiles()](#Init.createIdeConfigFiles) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [._updateLeaf(propertiersCur, defaultPropsCur, fieldName)](#Init._updateLeaf) ⇒ <code>void</code>
    * [._createIdeConfigFile(fileNameArr, [fileContent])](#Init._createIdeConfigFile) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [.initGitRepo([skipInteraction])](#Init.initGitRepo) ⇒ <code>Promise.&lt;{status:String, repoName:String}&gt;</code>
    * [.gitPush([skipInteraction])](#Init.gitPush) ⇒ <code>void</code>
    * [._addGitRemote([skipInteraction])](#Init._addGitRemote) ⇒ <code>String</code>
    * [._updateGitConfigUser([skipInteraction])](#Init._updateGitConfigUser) ⇒ <code>void</code>
    * [._getGitConfigUser()](#Init._getGitConfigUser) ⇒ <code>Promise.&lt;{&#x27;user.name&#x27;: String, &#x27;user.email&#x27;: String}&gt;</code>
    * [.initProject(properties, credentialsName, [skipInteraction])](#Init.initProject) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._downloadAllBUs(bu, gitStatus, [skipInteraction])](#Init._downloadAllBUs) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.upgradeProject(properties, [initial], [repoName])](#Init.upgradeProject) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [._getMissingCredentials(properties)](#Init._getMissingCredentials) ⇒ <code>Array.&lt;String&gt;</code>
    * [.installDependencies([repoName])](#Init.installDependencies) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [._getDefaultPackageJson([currentContent])](#Init._getDefaultPackageJson) ⇒ <code>Promise.&lt;{script: Object, author: String, license: String}&gt;</code>

<a name="Init.fixMcdevConfig"></a>

### Init.fixMcdevConfig(properties) ⇒ <code>Promise.&lt;Boolean&gt;</code>
helper method for this.upgradeProject that upgrades project config if needed

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - returns true if worked without errors  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | config file's json |

<a name="Init.createIdeConfigFiles"></a>

### Init.createIdeConfigFiles() ⇒ <code>Promise.&lt;Boolean&gt;</code>
handles creation/update of all config file from the boilerplate

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - status of config file creation  
<a name="Init._updateLeaf"></a>

### Init.\_updateLeaf(propertiersCur, defaultPropsCur, fieldName) ⇒ <code>void</code>
recursive helper for _fixMcdevConfig that adds missing settings

**Kind**: static method of [<code>Init</code>](#Init)  

| Param | Type | Description |
| --- | --- | --- |
| propertiersCur | <code>Object</code> | current sub-object of project settings |
| defaultPropsCur | <code>Object</code> | current sub-object of default settings |
| fieldName | <code>String</code> | dot-concatenated object-path that needs adding |

<a name="Init._createIdeConfigFile"></a>

### Init.\_createIdeConfigFile(fileNameArr, [fileContent]) ⇒ <code>Promise.&lt;Boolean&gt;</code>
handles creation/update of one config file from the boilerplate at a time

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - install successful or error occured  

| Param | Type | Description |
| --- | --- | --- |
| fileNameArr | <code>Array.&lt;String&gt;</code> | 0: path, 1: filename, 2: extension with dot |
| [fileContent] | <code>String</code> | in case we cannot copy files 1:1 this can be used to pass in content |

<a name="Init.initGitRepo"></a>

### Init.initGitRepo([skipInteraction]) ⇒ <code>Promise.&lt;{status:String, repoName:String}&gt;</code>
check if git repo exists and otherwise create one

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{status:String, repoName:String}&gt;</code> - success flag  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Object</code> | signals what to insert automatically for things usually asked via wizard |
| skipInteraction.gitRemoteUrl | <code>String</code> | URL of Git remote server |

<a name="Init.gitPush"></a>

### Init.gitPush([skipInteraction]) ⇒ <code>void</code>
offer to push the new repo straight to the server

**Kind**: static method of [<code>Init</code>](#Init)  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Boolean</code> \| <code>Object</code> | signals what to insert automatically for things usually asked via wizard |

<a name="Init._addGitRemote"></a>

### Init.\_addGitRemote([skipInteraction]) ⇒ <code>String</code>
offers to add the git remote origin

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>String</code> - repo name (optionally)  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Object</code> | signals what to insert automatically for things usually asked via wizard |
| skipInteraction.gitRemoteUrl | <code>String</code> | URL of Git remote server |

<a name="Init._updateGitConfigUser"></a>

### Init.\_updateGitConfigUser([skipInteraction]) ⇒ <code>void</code>
checks global config and ask to config the user info and then store it locally

**Kind**: static method of [<code>Init</code>](#Init)  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Object</code> \| <code>Boolean</code> | signals what to insert automatically for things usually asked via wizard |

<a name="Init._getGitConfigUser"></a>

### Init.\_getGitConfigUser() ⇒ <code>Promise.&lt;{&#x27;user.name&#x27;: String, &#x27;user.email&#x27;: String}&gt;</code>
retrieves the global user.name and user.email values

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{&#x27;user.name&#x27;: String, &#x27;user.email&#x27;: String}&gt;</code> - user.name and user.email  
<a name="Init.initProject"></a>

### Init.initProject(properties, credentialsName, [skipInteraction]) ⇒ <code>Promise.&lt;void&gt;</code>
Creates template file for properties.json

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | config file's json |
| credentialsName | <code>string</code> | identifying name of the installed package / project |
| [skipInteraction] | <code>Object</code> | signals what to insert automatically for things usually asked via wizard |
| skipInteraction.client_id | <code>String</code> | client id of installed package |
| skipInteraction.client_secret | <code>String</code> | client secret of installed package |
| skipInteraction.auth_url | <code>String</code> | auth_url of installed package |
| skipInteraction.eid | <code>String</code> | MID of the Parent Business Unit |
| skipInteraction.credentialsName | <code>String</code> | how you would like the credential to be named |
| skipInteraction.gitRemoteUrl | <code>String</code> | URL of Git remote server |

<a name="Init._downloadAllBUs"></a>

### Init.\_downloadAllBUs(bu, gitStatus, [skipInteraction]) ⇒ <code>Promise.&lt;void&gt;</code>
helper for this.initProject()

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| bu | <code>String</code> | cred/bu or cred/* or * |
| gitStatus | <code>String</code> | signals what state the git repo is in |
| [skipInteraction] | <code>Boolean</code> \| <code>Object</code> | signals what to insert automatically for things usually asked via wizard |

<a name="Init.upgradeProject"></a>

### Init.upgradeProject(properties, [initial], [repoName]) ⇒ <code>Promise.&lt;Boolean&gt;</code>
wrapper around npm dependency & configuration file setup

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - success flag  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | config file's json |
| [initial] | <code>Boolean</code> | print message if not part of initial setup |
| [repoName] | <code>String</code> | if git URL was provided earlier, the repo name was extracted to use it for npm init |

<a name="Init._getMissingCredentials"></a>

### Init.\_getMissingCredentials(properties) ⇒ <code>Array.&lt;String&gt;</code>
finds credentials that are set up in config but not in auth file

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Array.&lt;String&gt;</code> - list of credential names
TODO seems this is largely pointless - confirm with Joern  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>object</code> | javascript object in .mcdevrc.json |

<a name="Init.installDependencies"></a>

### Init.installDependencies([repoName]) ⇒ <code>Promise.&lt;Boolean&gt;</code>
initiates npm project and then
takes care of loading the pre-configured dependency list
from the boilerplate directory to them as dev-dependencies

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - install successful or error occured  

| Param | Type | Description |
| --- | --- | --- |
| [repoName] | <code>String</code> | if git URL was provided earlier, the repo name was extracted to use it for npm init |

<a name="Init._getDefaultPackageJson"></a>

### Init.\_getDefaultPackageJson([currentContent]) ⇒ <code>Promise.&lt;{script: Object, author: String, license: String}&gt;</code>
ensure we have certain default values in our config

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{script: Object, author: String, license: String}&gt;</code> - extended currentContent  

| Param | Type | Description |
| --- | --- | --- |
| [currentContent] | <code>Object</code> | what was read from existing package.json file |

<a name="Init"></a>

## Init
CLI helper class

**Kind**: global constant  

* [Init](#Init)
    * [.fixMcdevConfig(properties)](#Init.fixMcdevConfig) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [.createIdeConfigFiles()](#Init.createIdeConfigFiles) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [._updateLeaf(propertiersCur, defaultPropsCur, fieldName)](#Init._updateLeaf) ⇒ <code>void</code>
    * [._createIdeConfigFile(fileNameArr, [fileContent])](#Init._createIdeConfigFile) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [.initGitRepo([skipInteraction])](#Init.initGitRepo) ⇒ <code>Promise.&lt;{status:String, repoName:String}&gt;</code>
    * [.gitPush([skipInteraction])](#Init.gitPush) ⇒ <code>void</code>
    * [._addGitRemote([skipInteraction])](#Init._addGitRemote) ⇒ <code>String</code>
    * [._updateGitConfigUser([skipInteraction])](#Init._updateGitConfigUser) ⇒ <code>void</code>
    * [._getGitConfigUser()](#Init._getGitConfigUser) ⇒ <code>Promise.&lt;{&#x27;user.name&#x27;: String, &#x27;user.email&#x27;: String}&gt;</code>
    * [.initProject(properties, credentialsName, [skipInteraction])](#Init.initProject) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._downloadAllBUs(bu, gitStatus, [skipInteraction])](#Init._downloadAllBUs) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.upgradeProject(properties, [initial], [repoName])](#Init.upgradeProject) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [._getMissingCredentials(properties)](#Init._getMissingCredentials) ⇒ <code>Array.&lt;String&gt;</code>
    * [.installDependencies([repoName])](#Init.installDependencies) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [._getDefaultPackageJson([currentContent])](#Init._getDefaultPackageJson) ⇒ <code>Promise.&lt;{script: Object, author: String, license: String}&gt;</code>

<a name="Init.fixMcdevConfig"></a>

### Init.fixMcdevConfig(properties) ⇒ <code>Promise.&lt;Boolean&gt;</code>
helper method for this.upgradeProject that upgrades project config if needed

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - returns true if worked without errors  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | config file's json |

<a name="Init.createIdeConfigFiles"></a>

### Init.createIdeConfigFiles() ⇒ <code>Promise.&lt;Boolean&gt;</code>
handles creation/update of all config file from the boilerplate

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - status of config file creation  
<a name="Init._updateLeaf"></a>

### Init.\_updateLeaf(propertiersCur, defaultPropsCur, fieldName) ⇒ <code>void</code>
recursive helper for _fixMcdevConfig that adds missing settings

**Kind**: static method of [<code>Init</code>](#Init)  

| Param | Type | Description |
| --- | --- | --- |
| propertiersCur | <code>Object</code> | current sub-object of project settings |
| defaultPropsCur | <code>Object</code> | current sub-object of default settings |
| fieldName | <code>String</code> | dot-concatenated object-path that needs adding |

<a name="Init._createIdeConfigFile"></a>

### Init.\_createIdeConfigFile(fileNameArr, [fileContent]) ⇒ <code>Promise.&lt;Boolean&gt;</code>
handles creation/update of one config file from the boilerplate at a time

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - install successful or error occured  

| Param | Type | Description |
| --- | --- | --- |
| fileNameArr | <code>Array.&lt;String&gt;</code> | 0: path, 1: filename, 2: extension with dot |
| [fileContent] | <code>String</code> | in case we cannot copy files 1:1 this can be used to pass in content |

<a name="Init.initGitRepo"></a>

### Init.initGitRepo([skipInteraction]) ⇒ <code>Promise.&lt;{status:String, repoName:String}&gt;</code>
check if git repo exists and otherwise create one

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{status:String, repoName:String}&gt;</code> - success flag  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Object</code> | signals what to insert automatically for things usually asked via wizard |
| skipInteraction.gitRemoteUrl | <code>String</code> | URL of Git remote server |

<a name="Init.gitPush"></a>

### Init.gitPush([skipInteraction]) ⇒ <code>void</code>
offer to push the new repo straight to the server

**Kind**: static method of [<code>Init</code>](#Init)  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Boolean</code> \| <code>Object</code> | signals what to insert automatically for things usually asked via wizard |

<a name="Init._addGitRemote"></a>

### Init.\_addGitRemote([skipInteraction]) ⇒ <code>String</code>
offers to add the git remote origin

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>String</code> - repo name (optionally)  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Object</code> | signals what to insert automatically for things usually asked via wizard |
| skipInteraction.gitRemoteUrl | <code>String</code> | URL of Git remote server |

<a name="Init._updateGitConfigUser"></a>

### Init.\_updateGitConfigUser([skipInteraction]) ⇒ <code>void</code>
checks global config and ask to config the user info and then store it locally

**Kind**: static method of [<code>Init</code>](#Init)  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Object</code> \| <code>Boolean</code> | signals what to insert automatically for things usually asked via wizard |

<a name="Init._getGitConfigUser"></a>

### Init.\_getGitConfigUser() ⇒ <code>Promise.&lt;{&#x27;user.name&#x27;: String, &#x27;user.email&#x27;: String}&gt;</code>
retrieves the global user.name and user.email values

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{&#x27;user.name&#x27;: String, &#x27;user.email&#x27;: String}&gt;</code> - user.name and user.email  
<a name="Init.initProject"></a>

### Init.initProject(properties, credentialsName, [skipInteraction]) ⇒ <code>Promise.&lt;void&gt;</code>
Creates template file for properties.json

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | config file's json |
| credentialsName | <code>string</code> | identifying name of the installed package / project |
| [skipInteraction] | <code>Object</code> | signals what to insert automatically for things usually asked via wizard |
| skipInteraction.client_id | <code>String</code> | client id of installed package |
| skipInteraction.client_secret | <code>String</code> | client secret of installed package |
| skipInteraction.auth_url | <code>String</code> | auth_url of installed package |
| skipInteraction.eid | <code>String</code> | MID of the Parent Business Unit |
| skipInteraction.credentialsName | <code>String</code> | how you would like the credential to be named |
| skipInteraction.gitRemoteUrl | <code>String</code> | URL of Git remote server |

<a name="Init._downloadAllBUs"></a>

### Init.\_downloadAllBUs(bu, gitStatus, [skipInteraction]) ⇒ <code>Promise.&lt;void&gt;</code>
helper for this.initProject()

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| bu | <code>String</code> | cred/bu or cred/* or * |
| gitStatus | <code>String</code> | signals what state the git repo is in |
| [skipInteraction] | <code>Boolean</code> \| <code>Object</code> | signals what to insert automatically for things usually asked via wizard |

<a name="Init.upgradeProject"></a>

### Init.upgradeProject(properties, [initial], [repoName]) ⇒ <code>Promise.&lt;Boolean&gt;</code>
wrapper around npm dependency & configuration file setup

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - success flag  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | config file's json |
| [initial] | <code>Boolean</code> | print message if not part of initial setup |
| [repoName] | <code>String</code> | if git URL was provided earlier, the repo name was extracted to use it for npm init |

<a name="Init._getMissingCredentials"></a>

### Init.\_getMissingCredentials(properties) ⇒ <code>Array.&lt;String&gt;</code>
finds credentials that are set up in config but not in auth file

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Array.&lt;String&gt;</code> - list of credential names
TODO seems this is largely pointless - confirm with Joern  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>object</code> | javascript object in .mcdevrc.json |

<a name="Init.installDependencies"></a>

### Init.installDependencies([repoName]) ⇒ <code>Promise.&lt;Boolean&gt;</code>
initiates npm project and then
takes care of loading the pre-configured dependency list
from the boilerplate directory to them as dev-dependencies

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - install successful or error occured  

| Param | Type | Description |
| --- | --- | --- |
| [repoName] | <code>String</code> | if git URL was provided earlier, the repo name was extracted to use it for npm init |

<a name="Init._getDefaultPackageJson"></a>

### Init.\_getDefaultPackageJson([currentContent]) ⇒ <code>Promise.&lt;{script: Object, author: String, license: String}&gt;</code>
ensure we have certain default values in our config

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{script: Object, author: String, license: String}&gt;</code> - extended currentContent  

| Param | Type | Description |
| --- | --- | --- |
| [currentContent] | <code>Object</code> | what was read from existing package.json file |

<a name="Init"></a>

## Init
CLI helper class

**Kind**: global constant  

* [Init](#Init)
    * [.fixMcdevConfig(properties)](#Init.fixMcdevConfig) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [.createIdeConfigFiles()](#Init.createIdeConfigFiles) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [._updateLeaf(propertiersCur, defaultPropsCur, fieldName)](#Init._updateLeaf) ⇒ <code>void</code>
    * [._createIdeConfigFile(fileNameArr, [fileContent])](#Init._createIdeConfigFile) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [.initGitRepo([skipInteraction])](#Init.initGitRepo) ⇒ <code>Promise.&lt;{status:String, repoName:String}&gt;</code>
    * [.gitPush([skipInteraction])](#Init.gitPush) ⇒ <code>void</code>
    * [._addGitRemote([skipInteraction])](#Init._addGitRemote) ⇒ <code>String</code>
    * [._updateGitConfigUser([skipInteraction])](#Init._updateGitConfigUser) ⇒ <code>void</code>
    * [._getGitConfigUser()](#Init._getGitConfigUser) ⇒ <code>Promise.&lt;{&#x27;user.name&#x27;: String, &#x27;user.email&#x27;: String}&gt;</code>
    * [.initProject(properties, credentialsName, [skipInteraction])](#Init.initProject) ⇒ <code>Promise.&lt;void&gt;</code>
    * [._downloadAllBUs(bu, gitStatus, [skipInteraction])](#Init._downloadAllBUs) ⇒ <code>Promise.&lt;void&gt;</code>
    * [.upgradeProject(properties, [initial], [repoName])](#Init.upgradeProject) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [._getMissingCredentials(properties)](#Init._getMissingCredentials) ⇒ <code>Array.&lt;String&gt;</code>
    * [.installDependencies([repoName])](#Init.installDependencies) ⇒ <code>Promise.&lt;Boolean&gt;</code>
    * [._getDefaultPackageJson([currentContent])](#Init._getDefaultPackageJson) ⇒ <code>Promise.&lt;{script: Object, author: String, license: String}&gt;</code>

<a name="Init.fixMcdevConfig"></a>

### Init.fixMcdevConfig(properties) ⇒ <code>Promise.&lt;Boolean&gt;</code>
helper method for this.upgradeProject that upgrades project config if needed

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - returns true if worked without errors  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | config file's json |

<a name="Init.createIdeConfigFiles"></a>

### Init.createIdeConfigFiles() ⇒ <code>Promise.&lt;Boolean&gt;</code>
handles creation/update of all config file from the boilerplate

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - status of config file creation  
<a name="Init._updateLeaf"></a>

### Init.\_updateLeaf(propertiersCur, defaultPropsCur, fieldName) ⇒ <code>void</code>
recursive helper for _fixMcdevConfig that adds missing settings

**Kind**: static method of [<code>Init</code>](#Init)  

| Param | Type | Description |
| --- | --- | --- |
| propertiersCur | <code>Object</code> | current sub-object of project settings |
| defaultPropsCur | <code>Object</code> | current sub-object of default settings |
| fieldName | <code>String</code> | dot-concatenated object-path that needs adding |

<a name="Init._createIdeConfigFile"></a>

### Init.\_createIdeConfigFile(fileNameArr, [fileContent]) ⇒ <code>Promise.&lt;Boolean&gt;</code>
handles creation/update of one config file from the boilerplate at a time

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - install successful or error occured  

| Param | Type | Description |
| --- | --- | --- |
| fileNameArr | <code>Array.&lt;String&gt;</code> | 0: path, 1: filename, 2: extension with dot |
| [fileContent] | <code>String</code> | in case we cannot copy files 1:1 this can be used to pass in content |

<a name="Init.initGitRepo"></a>

### Init.initGitRepo([skipInteraction]) ⇒ <code>Promise.&lt;{status:String, repoName:String}&gt;</code>
check if git repo exists and otherwise create one

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{status:String, repoName:String}&gt;</code> - success flag  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Object</code> | signals what to insert automatically for things usually asked via wizard |
| skipInteraction.gitRemoteUrl | <code>String</code> | URL of Git remote server |

<a name="Init.gitPush"></a>

### Init.gitPush([skipInteraction]) ⇒ <code>void</code>
offer to push the new repo straight to the server

**Kind**: static method of [<code>Init</code>](#Init)  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Boolean</code> \| <code>Object</code> | signals what to insert automatically for things usually asked via wizard |

<a name="Init._addGitRemote"></a>

### Init.\_addGitRemote([skipInteraction]) ⇒ <code>String</code>
offers to add the git remote origin

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>String</code> - repo name (optionally)  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Object</code> | signals what to insert automatically for things usually asked via wizard |
| skipInteraction.gitRemoteUrl | <code>String</code> | URL of Git remote server |

<a name="Init._updateGitConfigUser"></a>

### Init.\_updateGitConfigUser([skipInteraction]) ⇒ <code>void</code>
checks global config and ask to config the user info and then store it locally

**Kind**: static method of [<code>Init</code>](#Init)  

| Param | Type | Description |
| --- | --- | --- |
| [skipInteraction] | <code>Object</code> \| <code>Boolean</code> | signals what to insert automatically for things usually asked via wizard |

<a name="Init._getGitConfigUser"></a>

### Init.\_getGitConfigUser() ⇒ <code>Promise.&lt;{&#x27;user.name&#x27;: String, &#x27;user.email&#x27;: String}&gt;</code>
retrieves the global user.name and user.email values

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{&#x27;user.name&#x27;: String, &#x27;user.email&#x27;: String}&gt;</code> - user.name and user.email  
<a name="Init.initProject"></a>

### Init.initProject(properties, credentialsName, [skipInteraction]) ⇒ <code>Promise.&lt;void&gt;</code>
Creates template file for properties.json

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | config file's json |
| credentialsName | <code>string</code> | identifying name of the installed package / project |
| [skipInteraction] | <code>Object</code> | signals what to insert automatically for things usually asked via wizard |
| skipInteraction.client_id | <code>String</code> | client id of installed package |
| skipInteraction.client_secret | <code>String</code> | client secret of installed package |
| skipInteraction.auth_url | <code>String</code> | auth_url of installed package |
| skipInteraction.eid | <code>String</code> | MID of the Parent Business Unit |
| skipInteraction.credentialsName | <code>String</code> | how you would like the credential to be named |
| skipInteraction.gitRemoteUrl | <code>String</code> | URL of Git remote server |

<a name="Init._downloadAllBUs"></a>

### Init.\_downloadAllBUs(bu, gitStatus, [skipInteraction]) ⇒ <code>Promise.&lt;void&gt;</code>
helper for this.initProject()

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;void&gt;</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| bu | <code>String</code> | cred/bu or cred/* or * |
| gitStatus | <code>String</code> | signals what state the git repo is in |
| [skipInteraction] | <code>Boolean</code> \| <code>Object</code> | signals what to insert automatically for things usually asked via wizard |

<a name="Init.upgradeProject"></a>

### Init.upgradeProject(properties, [initial], [repoName]) ⇒ <code>Promise.&lt;Boolean&gt;</code>
wrapper around npm dependency & configuration file setup

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - success flag  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | config file's json |
| [initial] | <code>Boolean</code> | print message if not part of initial setup |
| [repoName] | <code>String</code> | if git URL was provided earlier, the repo name was extracted to use it for npm init |

<a name="Init._getMissingCredentials"></a>

### Init.\_getMissingCredentials(properties) ⇒ <code>Array.&lt;String&gt;</code>
finds credentials that are set up in config but not in auth file

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Array.&lt;String&gt;</code> - list of credential names
TODO seems this is largely pointless - confirm with Joern  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>object</code> | javascript object in .mcdevrc.json |

<a name="Init.installDependencies"></a>

### Init.installDependencies([repoName]) ⇒ <code>Promise.&lt;Boolean&gt;</code>
initiates npm project and then
takes care of loading the pre-configured dependency list
from the boilerplate directory to them as dev-dependencies

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;Boolean&gt;</code> - install successful or error occured  

| Param | Type | Description |
| --- | --- | --- |
| [repoName] | <code>String</code> | if git URL was provided earlier, the repo name was extracted to use it for npm init |

<a name="Init._getDefaultPackageJson"></a>

### Init.\_getDefaultPackageJson([currentContent]) ⇒ <code>Promise.&lt;{script: Object, author: String, license: String}&gt;</code>
ensure we have certain default values in our config

**Kind**: static method of [<code>Init</code>](#Init)  
**Returns**: <code>Promise.&lt;{script: Object, author: String, license: String}&gt;</code> - extended currentContent  

| Param | Type | Description |
| --- | --- | --- |
| [currentContent] | <code>Object</code> | what was read from existing package.json file |

<a name="Util"></a>

## Util
Util that contains logger and simple util methods

**Kind**: global constant  

* [Util](#Util)
    * [.logger](#Util.logger)
    * [.isTrue(attrValue)](#Util.isTrue) ⇒ <code>boolean</code>
    * [.isFalse(attrValue)](#Util.isFalse) ⇒ <code>boolean</code>
    * [.getDefaultProperties()](#Util.getDefaultProperties) ⇒ <code>object</code>
    * [.getRetrieveTypeChoices()](#Util.getRetrieveTypeChoices) ⇒ <code>Array.&lt;string&gt;</code>
    * [.checkProperties(properties, [silent])](#Util.checkProperties) ⇒ <code>Promise.&lt;(boolean\|Array.&lt;String&gt;)&gt;</code>
    * [.metadataLogger(level, type, method, payload, [source])](#Util.metadataLogger) ⇒ <code>void</code>
    * [.replaceByObject(str, obj)](#Util.replaceByObject) ⇒ <code>String</code> \| <code>Object</code>
    * [.inverseGet(objs, val)](#Util.inverseGet) ⇒ <code>String</code>
    * [.getMetadataHierachy(metadataTypes)](#Util.getMetadataHierachy) ⇒ <code>Array.&lt;String&gt;</code>
    * [.resolveObjPath(path, obj)](#Util.resolveObjPath) ⇒ <code>any</code>
    * [.execSync(cmd, [args])](#Util.execSync) ⇒ <code>undefined</code>
    * [.templateSearchResult(results, keyToSearch, searchValue)](#Util.templateSearchResult) ⇒ <code>MetadataTypeItem</code>
    * [.setLoggingLevel(argv)](#Util.setLoggingLevel) ⇒ <code>void</code>

<a name="Util.logger"></a>

### Util.logger
Logger that creates timestamped log file in 'logs/' directory

**Kind**: static property of [<code>Util</code>](#Util)  
<a name="Util.isTrue"></a>

### Util.isTrue(attrValue) ⇒ <code>boolean</code>
SFMC accepts multiple true values for Boolean attributes for which we are checking here

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - attribute value == true ? true : false  

| Param | Type | Description |
| --- | --- | --- |
| attrValue | <code>\*</code> | value |

<a name="Util.isFalse"></a>

### Util.isFalse(attrValue) ⇒ <code>boolean</code>
SFMC accepts multiple false values for Boolean attributes for which we are checking here

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>boolean</code> - attribute value == false ? true : false  

| Param | Type | Description |
| --- | --- | --- |
| attrValue | <code>\*</code> | value |

<a name="Util.getDefaultProperties"></a>

### Util.getDefaultProperties() ⇒ <code>object</code>
defines how the properties.json should look like
used for creating a template and for checking if variables are set

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>object</code> - default properties  
<a name="Util.getRetrieveTypeChoices"></a>

### Util.getRetrieveTypeChoices() ⇒ <code>Array.&lt;string&gt;</code>
helper for getDefaultProperties()

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Array.&lt;string&gt;</code> - type choices  
<a name="Util.checkProperties"></a>

### Util.checkProperties(properties, [silent]) ⇒ <code>Promise.&lt;(boolean\|Array.&lt;String&gt;)&gt;</code>
check if the config file is correctly formatted and has values

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Promise.&lt;(boolean\|Array.&lt;String&gt;)&gt;</code> - file structure ok OR list of fields to be fixed  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>object</code> | javascript object in .mcdevrc.json |
| [silent] | <code>boolean</code> | set to true for internal use w/o cli output |

<a name="Util.metadataLogger"></a>

### Util.metadataLogger(level, type, method, payload, [source]) ⇒ <code>void</code>
Logger helper for Metadata functions

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| level | <code>String</code> | of log (error, info, warn) |
| type | <code>String</code> | of metadata being referenced |
| method | <code>String</code> | name which log was called from |
| payload | <code>\*</code> | generic object which details the error |
| [source] | <code>String</code> | key/id of metadata which relates to error |

<a name="Util.replaceByObject"></a>

### Util.replaceByObject(str, obj) ⇒ <code>String</code> \| <code>Object</code>
replaces values in a JSON object string, based on a series of
key-value pairs (obj)

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>String</code> \| <code>Object</code> - replaced version of str  

| Param | Type | Description |
| --- | --- | --- |
| str | <code>String</code> \| <code>Object</code> | JSON object or its stringified version, which has values to be replaced |
| obj | <code>TemplateMap</code> | key value object which contains keys to be replaced and values to be replaced with |

<a name="Util.inverseGet"></a>

### Util.inverseGet(objs, val) ⇒ <code>String</code>
get key of an object based on the first matching value

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>String</code> - key  

| Param | Type | Description |
| --- | --- | --- |
| objs | <code>Object</code> | object of objects to be searched |
| val | <code>String</code> | value to be searched for |

<a name="Util.getMetadataHierachy"></a>

### Util.getMetadataHierachy(metadataTypes) ⇒ <code>Array.&lt;String&gt;</code>
Returns Order in which metadata needs to be retrieved/deployed

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>Array.&lt;String&gt;</code> - retrieve/deploy order as array  

| Param | Type | Description |
| --- | --- | --- |
| metadataTypes | <code>Array.&lt;String&gt;</code> | which should be retrieved/deployed |

<a name="Util.resolveObjPath"></a>

### Util.resolveObjPath(path, obj) ⇒ <code>any</code>
let's you dynamically walk down an object and get a value

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>any</code> - value of obj.path  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>String</code> | 'fieldA.fieldB.fieldC' |
| obj | <code>Object</code> | some parent object |

<a name="Util.execSync"></a>

### Util.execSync(cmd, [args]) ⇒ <code>undefined</code>
helper to run other commands as if run manually by user

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| cmd | <code>string</code> | to be executed command |
| [args] | <code>Array.&lt;string&gt;</code> | list of arguments |

<a name="Util.templateSearchResult"></a>

### Util.templateSearchResult(results, keyToSearch, searchValue) ⇒ <code>MetadataTypeItem</code>
standardize check to ensure only one result is returned from template search

**Kind**: static method of [<code>Util</code>](#Util)  
**Returns**: <code>MetadataTypeItem</code> - metadata to be used in building template  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Array.&lt;MetadataTypeItem&gt;</code> | array of metadata |
| keyToSearch | <code>string</code> | the field which contains the searched value |
| searchValue | <code>string</code> | the value which is being looked for |

<a name="Util.setLoggingLevel"></a>

### Util.setLoggingLevel(argv) ⇒ <code>void</code>
configures what is displayed in the console

**Kind**: static method of [<code>Util</code>](#Util)  

| Param | Type | Description |
| --- | --- | --- |
| argv | <code>Object</code> | list of command line parameters given by user |
| [argv.silent] | <code>boolean</code> | only errors printed to CLI |
| [argv.verbose] | <code>boolean</code> | chatty user CLI output |
| [argv.debug] | <code>boolean</code> | enables developer output & features |

<a name="getUserName"></a>

## getUserName(userList, item, fieldname) ⇒ <code>string</code>
**Kind**: global function  
**Returns**: <code>string</code> - username or user id or 'n/a'  

| Param | Type | Description |
| --- | --- | --- |
| userList | <code>object.&lt;string, string&gt;</code> | user-id > user-name map |
| item | <code>object.&lt;string, string&gt;</code> | single metadata item |
| fieldname | <code>string</code> | name of field containing the info |

<a name="createNewLoggerTransport"></a>

## createNewLoggerTransport() ⇒ <code>object</code>
wrapper around our standard winston logging to console and logfile

**Kind**: global function  
**Returns**: <code>object</code> - initiated logger for console and file  
<a name="startLogger"></a>

## startLogger() ⇒ <code>void</code>
initiate winston logger

**Kind**: global function  
<a name="CodeExtractItem"></a>

## CodeExtractItem : <code>Object.&lt;string, any&gt;</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| json | <code>AssetItem</code> | metadata of one item w/o code |
| codeArr | <code>Array.&lt;MetadataType.CodeExtract&gt;</code> | list of code snippets in this item |
| subFolder | <code>Array.&lt;string&gt;</code> | mostly set to null, otherwise list of subfolders |

<a name="AutomationMap"></a>

## AutomationMap : <code>Object</code>
REST format

**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | name (not key) of activity |
| [objectTypeId] | <code>string</code> | Id of assoicated activity type; see this.definition.activityTypeMapping |
| [activityObjectId] | <code>string</code> | Object Id of assoicated metadata item |
| displayOrder | <code>number</code> | order within step; starts with 1 or higher number |
| r__type | <code>string</code> | see this.definition.activityTypeMapping |
| name | <code>string</code> | description |
| [annotation] | <code>string</code> | equals AutomationStep.name |
| step | <code>number</code> | step iterator |
| [stepNumber] | <code>number</code> | step iterator, automatically set during deployment |
| activities | <code>Array.&lt;AutomationActivity&gt;</code> | - |
| typeId | <code>number</code> | ? |
| startDate | <code>string</code> | example: '2021-05-07T09:00:00' |
| endDate | <code>string</code> | example: '2021-05-07T09:00:00' |
| icalRecur | <code>string</code> | example: 'FREQ=DAILY;UNTIL=20790606T160000;INTERVAL=1' |
| timezoneName | <code>string</code> | example: 'W. Europe Standard Time'; see this.definition.timeZoneMapping |
| [timezoneId] | <code>number</code> | see this.definition.timeZoneMapping |
| Recurrence | <code>Object</code> | - |
| Recurrence.$ | <code>Object</code> | {'xsi:type': keyStem + 'lyRecurrence'} |
| [Recurrence.YearlyRecurrencePatternType] | <code>&#x27;ByYear&#x27;</code> | * currently not supported by tool * |
| [Recurrence.MonthlyRecurrencePatternType] | <code>&#x27;ByMonth&#x27;</code> | * currently not supported by tool * |
| [Recurrence.WeeklyRecurrencePatternType] | <code>&#x27;ByWeek&#x27;</code> | * currently not supported by tool * |
| [Recurrence.DailyRecurrencePatternType] | <code>&#x27;ByDay&#x27;</code> | - |
| [Recurrence.MinutelyRecurrencePatternType] | <code>&#x27;Interval&#x27;</code> | - |
| [Recurrence.HourlyRecurrencePatternType] | <code>&#x27;Interval&#x27;</code> | - |
| [Recurrence.YearInterval] | <code>number</code> | 1..n * currently not supported by tool * |
| [Recurrence.MonthInterval] | <code>number</code> | 1..n * currently not supported by tool * |
| [Recurrence.WeekInterval] | <code>number</code> | 1..n * currently not supported by tool * |
| [Recurrence.DayInterval] | <code>number</code> | 1..n |
| [Recurrence.HourInterval] | <code>number</code> | 1..n |
| [Recurrence.MinuteInterval] | <code>number</code> | 1..n |
| _interval | <code>number</code> | internal variable for CLI output only |
| TimeZone | <code>Object</code> | - |
| TimeZone.ID | <code>number</code> | AutomationSchedule.timezoneId |
| _timezoneString | <code>string</code> | internal variable for CLI output only |
| StartDateTime | <code>string</code> | AutomationSchedule.startDate |
| EndDateTime | <code>string</code> | AutomationSchedule.endDate |
| _StartDateTime | <code>string</code> | AutomationSchedule.startDate; internal variable for CLI output only |
| RecurrenceRangeType | <code>&#x27;EndOn&#x27;</code> \| <code>&#x27;EndAfter&#x27;</code> | set to 'EndOn' if AutomationSchedule.icalRecur contains 'UNTIL'; otherwise to 'EndAfter' |
| Occurrences | <code>number</code> | only exists if RecurrenceRangeType=='EndAfter' |
| [id] | <code>string</code> | Object Id |
| key | <code>string</code> | key |
| name | <code>string</code> | name |
| description | <code>string</code> | - |
| type | <code>&#x27;scheduled&#x27;</code> \| <code>&#x27;triggered&#x27;</code> | Starting Source = Schedule / File Drop |
| status | <code>&#x27;Scheduled&#x27;</code> \| <code>&#x27;Running&#x27;</code> | - |
| [schedule] | <code>AutomationSchedule</code> | only existing if type=scheduled |
| [fileTrigger] | <code>Object</code> | only existing if type=triggered |
| fileTrigger.fileNamingPattern | <code>string</code> | - |
| fileTrigger.fileNamePatternTypeId | <code>string</code> | - |
| fileTrigger.folderLocationText | <code>string</code> | - |
| fileTrigger.queueFiles | <code>string</code> | - |
| [startSource] | <code>Object</code> | - |
| [startSource.schedule] | <code>AutomationSchedule</code> | rewritten to AutomationItem.schedule |
| [startSource.fileDrop] | <code>Object</code> | rewritten to AutomationItem.fileTrigger |
| startSource.fileDrop.fileNamingPattern | <code>string</code> | - |
| startSource.fileDrop.fileNamePatternTypeId | <code>string</code> | - |
| startSource.fileDrop.folderLocation | <code>string</code> | - |
| startSource.fileDrop.queueFiles | <code>string</code> | - |
| startSource.typeId | <code>number</code> | - |
| steps | <code>Array.&lt;AutomationStep&gt;</code> | - |
| r__folder_Path | <code>string</code> | folder path |
| [categoryId] | <code>string</code> | holds folder ID, replaced with r__folder_Path during retrieve |

<a name="DataExtensionMap"></a>

## DataExtensionMap : <code>Object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| CustomerKey | <code>string</code> | key |
| Name | <code>string</code> | name |
| Description | <code>string</code> | - |
| IsSendable | <code>&#x27;true&#x27;</code> \| <code>&#x27;false&#x27;</code> | - |
| IsTestable | <code>&#x27;true&#x27;</code> \| <code>&#x27;false&#x27;</code> | - |
| SendableDataExtensionField | <code>Object</code> | - |
| SendableDataExtensionField.Name | <code>string</code> | - |
| SendableSubscriberField | <code>Object</code> | - |
| SendableSubscriberField.Name | <code>string</code> | - |
| Fields | <code>Array.&lt;DataExtensionField.DataExtensionFieldItem&gt;</code> | list of DE fields |
| r__folder_ContentType | <code>&#x27;dataextension&#x27;</code> \| <code>&#x27;salesforcedataextension&#x27;</code> \| <code>&#x27;synchronizeddataextension&#x27;</code> \| <code>&#x27;shared\_dataextension&#x27;</code> \| <code>&#x27;shared\_salesforcedataextension&#x27;</code> | retrieved from associated folder |
| r__folder_Path | <code>string</code> | folder path in which this DE is saved |
| [CategoryID] | <code>string</code> | holds folder ID, replaced with r__folder_Path during retrieve |
| [r__dataExtensionTemplate_Name] | <code>string</code> | name of optionally associated DE template |
| [Template] | <code>Object</code> | - |
| [Template.CustomerKey] | <code>string</code> | key of optionally associated DE teplate |

<a name="DataExtensionFieldMap"></a>

## DataExtensionFieldMap : <code>Object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| [ObjectID] | <code>string</code> | id |
| [CustomerKey] | <code>string</code> | key in format [DEkey].[FieldName] |
| [DataExtension] | <code>Object</code> | - |
| DataExtension.CustomerKey | <code>string</code> | key of DE |
| Name | <code>string</code> | name of field |
| [Name_new] | <code>string</code> | custom attribute that is only used when trying to rename a field from Name to Name_new |
| DefaultValue | <code>string</code> | empty string for not set |
| IsRequired | <code>&#x27;true&#x27;</code> \| <code>&#x27;false&#x27;</code> | - |
| IsPrimaryKey | <code>&#x27;true&#x27;</code> \| <code>&#x27;false&#x27;</code> | - |
| Ordinal | <code>string</code> | 1, 2, 3, ... |
| FieldType | <code>&#x27;Text&#x27;</code> \| <code>&#x27;Number&#x27;</code> \| <code>&#x27;Date&#x27;</code> \| <code>&#x27;Boolean&#x27;</code> \| <code>&#x27;Decimal&#x27;</code> \| <code>&#x27;EmailAddress&#x27;</code> \| <code>&#x27;Phone&#x27;</code> \| <code>&#x27;Locale&#x27;</code> | can only be set on create |
| Scale | <code>string</code> | the number of places after the decimal that the field can hold; example: "0","1", ... |

<a name="CodeExtract"></a>

## CodeExtract : <code>Object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| json | <code>Util.MetadataTypeItem</code> | metadata of one item w/o code |
| codeArr | [<code>Array.&lt;CodeExtract&gt;</code>](#CodeExtract) | list of code snippets in this item |
| subFolder | <code>Array.&lt;string&gt;</code> | mostly set to null, otherwise list of subfolders |
| subFolder | <code>Array.&lt;string&gt;</code> | mostly set to null, otherwise subfolders path split into elements |
| fileName | <code>string</code> | name of file w/o extension |
| fileExt | <code>string</code> | file extension |
| content | <code>string</code> | file content |
| [encoding] | <code>&#x27;base64&#x27;</code> | optional for binary files |

<a name="CodeExtractItem"></a>

## CodeExtractItem : <code>Object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | name |
| key | <code>string</code> | key |
| description | <code>string</code> | - |
| targetKey | <code>string</code> | key of target data extension |
| createdDate | <code>string</code> | e.g. "2020-09-14T01:42:03.017" |
| modifiedDate | <code>string</code> | e.g. "2020-09-14T01:42:03.017" |
| targetUpdateTypeName | <code>&#x27;Overwrite&#x27;</code> \| <code>&#x27;Update&#x27;</code> \| <code>&#x27;Append&#x27;</code> | defines how the query writes into the target data extension |
| [targetUpdateTypeId] | <code>0</code> \| <code>1</code> \| <code>2</code> | mapped to targetUpdateTypeName via this.definition.targetUpdateTypeMapping |
| [targetId] | <code>string</code> | Object ID of DE (removed before save) |
| [targetDescription] | <code>string</code> | Description DE (removed before save) |
| isFrozen | <code>boolean</code> | looks like this is always set to false |
| [queryText] | <code>string</code> | contains SQL query with line breaks converted to '\n'. The content is extracted during retrieval and written into a separate *.sql file |
| [categoryId] | <code>string</code> | holds folder ID, replaced with r__folder_Path during retrieve |
| r__folder_Path | <code>string</code> | folder path in which this DE is saved |
| json | <code>QueryItem</code> | metadata of one item w/o code |
| codeArr | <code>Array.&lt;MetadataType.CodeExtract&gt;</code> | list of code snippets in this item |
| subFolder | <code>Array.&lt;string&gt;</code> | mostly set to null, otherwise list of subfolders |

<a name="CodeExtractItem"></a>

## CodeExtractItem : <code>Object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | name |
| key | <code>string</code> | key |
| description | <code>string</code> | - |
| createdDate | <code>string</code> | e.g. "2020-09-14T01:42:03.017" |
| modifiedDate | <code>string</code> | e.g. "2020-09-14T01:42:03.017" |
| [script] | <code>string</code> | contains script with line breaks converted to '\n'. The content is extracted during retrieval and written into a separate *.ssjs file |
| [categoryId] | <code>string</code> | holds folder ID, replaced with r__folder_Path during retrieve |
| r__folder_Path | <code>string</code> | folder path in which this DE is saved |
| json | <code>ScriptItem</code> | metadata of one item w/o code |
| codeArr | <code>Array.&lt;MetadataType.CodeExtract&gt;</code> | list of code snippets in this item |
| subFolder | <code>Array.&lt;string&gt;</code> | mostly set to null, otherwise list of subfolders |

<a name="MetadataType"></a>

## MetadataType : <code>require(&#x27;../metadataTypes/MetadataType.js&#x27;)</code>
**Kind**: global typedef  

* [MetadataType](#MetadataType) : <code>require(&#x27;../metadataTypes/MetadataType.js&#x27;)</code>
    * _instance_
        * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
        * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
        * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
        * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
        * [.postRetrieveTasks(metadata, targetDir, [isTemplating])](#MetadataType+postRetrieveTasks) ⇒ <code>Util.MetadataTypeItem</code>
        * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
        * [.retrieve(retrieveDir, [additionalFields], [subType])](#MetadataType+retrieve) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.retrieveForCache([subType])](#MetadataType+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
        * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
        * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
        * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
        * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
        * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
        * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
        * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
        * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
        * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
        * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
        * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
        * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
        * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
        * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
        * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
        * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
        * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
        * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
        * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
        * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
        * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
        * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
        * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
        * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
        * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>
    * _static_
        * [.client](#MetadataType.client) : <code>Util.SDK</code>
        * [.properties](#MetadataType.properties) : <code>Util.MultiMetadataTypeMap</code>
        * [.subType](#MetadataType.subType) : <code>string</code>
        * [.buObject](#MetadataType.buObject) : <code>Object</code>

<a name="MetadataType+getJsonFromFS"></a>

### metadataType.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### metadataType.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### metadataType.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### metadataType.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+postRetrieveTasks"></a>

### metadataType.postRetrieveTasks(metadata, targetDir, [isTemplating]) ⇒ <code>Util.MetadataTypeItem</code>
Gets executed after retreive of metadata type

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Util.MetadataTypeItem</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| targetDir | <code>string</code> | folder where retrieves should be saved |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="MetadataType+overrideKeyWithName"></a>

### metadataType.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieve"></a>

### metadataType.retrieve(retrieveDir, [additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveChangelog"></a>

### metadataType.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveForCache"></a>

### metadataType.retrieveForCache([subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### metadataType.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### metadataType.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### metadataType.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### metadataType.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### metadataType.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### metadataType.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### metadataType.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### metadataType.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### metadataType.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### metadataType.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### metadataType.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### metadataType.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### metadataType.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### metadataType.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### metadataType.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### metadataType.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### metadataType.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### metadataType.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### metadataType.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### metadataType.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### metadataType.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### metadataType.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### metadataType.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### metadataType.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### metadataType.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### metadataType.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### metadataType.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### metadataType.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### metadataType.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### metadataType.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="MetadataType.client"></a>

### MetadataType.client : <code>Util.SDK</code>
**Kind**: static property of [<code>MetadataType</code>](#MetadataType)  
<a name="MetadataType.properties"></a>

### MetadataType.properties : <code>Util.MultiMetadataTypeMap</code>
**Kind**: static property of [<code>MetadataType</code>](#MetadataType)  
<a name="MetadataType.subType"></a>

### MetadataType.subType : <code>string</code>
**Kind**: static property of [<code>MetadataType</code>](#MetadataType)  
<a name="MetadataType.buObject"></a>

### MetadataType.buObject : <code>Object</code>
**Kind**: static property of [<code>MetadataType</code>](#MetadataType)  
<a name="BuObject"></a>

## BuObject : <code>Object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| credential | <code>String</code> | client_id for sfmc-sdk auth |
| mid | <code>Integer</code> | ID of Business Unit to authenticate with |
| eid | <code>Integer</code> | Parent ID of Business Unit to authenticate with |
| businessUnit | <code>String</code> | name of Business Unit to authenticate with |

<a name="AuthObject"></a>

## AuthObject : <code>Object</code>
**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| client_id | <code>String</code> | client_id client_id for sfmc-sdk auth |
| client_secret | <code>String</code> | client_secret for sfmc-sdk auth |
| account_id | <code>Integer</code> | mid of business unit to auth against |
| auth_url | <code>String</code> | authentication base url |

<a name="MetadataType"></a>

## MetadataType : <code>require(&#x27;../metadataTypes/MetadataType.js&#x27;)</code>
**Kind**: global typedef  

* [MetadataType](#MetadataType) : <code>require(&#x27;../metadataTypes/MetadataType.js&#x27;)</code>
    * _instance_
        * [.getJsonFromFS(dir, [listBadKeys])](#MetadataType+getJsonFromFS) ⇒ <code>Object</code>
        * [.getFieldNamesToRetrieve([additionalFields])](#MetadataType+getFieldNamesToRetrieve) ⇒ <code>Array.&lt;string&gt;</code>
        * [.deploy(metadata, deployDir, retrieveDir)](#MetadataType+deploy) ⇒ <code>Promise.&lt;Object&gt;</code>
        * [.postDeployTasks(metadata, originalMetadata)](#MetadataType+postDeployTasks) ⇒ <code>void</code>
        * [.postRetrieveTasks(metadata, targetDir, [isTemplating])](#MetadataType+postRetrieveTasks) ⇒ <code>Util.MetadataTypeItem</code>
        * [.overrideKeyWithName(metadata, [warningMsg])](#MetadataType+overrideKeyWithName) ⇒ <code>void</code>
        * [.retrieve(retrieveDir, [additionalFields], [subType])](#MetadataType+retrieve) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.retrieveChangelog([additionalFields], [subType])](#MetadataType+retrieveChangelog) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.retrieveForCache([subType])](#MetadataType+retrieveForCache) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.retrieveAsTemplate(templateDir, name, templateVariables, [subType])](#MetadataType+retrieveAsTemplate) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.preDeployTasks(metadata, deployDir)](#MetadataType+preDeployTasks) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
        * [.create(metadata, deployDir)](#MetadataType+create) ⇒ <code>void</code>
        * [.update(metadata, [metadataBefore])](#MetadataType+update) ⇒ <code>void</code>
        * [.upsert(metadata, deployDir)](#MetadataType+upsert) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
        * [.createREST(metadataEntry, uri)](#MetadataType+createREST) ⇒ <code>Promise</code>
        * [.createSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+createSOAP) ⇒ <code>Promise</code>
        * [.updateREST(metadataEntry, uri)](#MetadataType+updateREST) ⇒ <code>Promise</code>
        * [.updateSOAP(metadataEntry, [overrideType], [handleOutside])](#MetadataType+updateSOAP) ⇒ <code>Promise</code>
        * [.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType])](#MetadataType+retrieveSOAP) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables])](#MetadataType+retrieveREST) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.parseResponseBody(body)](#MetadataType+parseResponseBody) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
        * [.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin)](#MetadataType+deleteFieldByDefinition) ⇒ <code>void</code>
        * [.removeNotCreateableFields(metadataEntry)](#MetadataType+removeNotCreateableFields) ⇒ <code>void</code>
        * [.removeNotUpdateableFields(metadataEntry)](#MetadataType+removeNotUpdateableFields) ⇒ <code>void</code>
        * [.keepTemplateFields(metadataEntry)](#MetadataType+keepTemplateFields) ⇒ <code>void</code>
        * [.keepRetrieveFields(metadataEntry)](#MetadataType+keepRetrieveFields) ⇒ <code>void</code>
        * [.isFiltered(metadataEntry, [include])](#MetadataType+isFiltered) ⇒ <code>boolean</code>
        * [.isFilteredFolder(metadataEntry, [include])](#MetadataType+isFilteredFolder) ⇒ <code>boolean</code>
        * [.saveResults(results, retrieveDir, [overrideType], [templateVariables])](#MetadataType+saveResults) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
        * [.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName)](#MetadataType+buildDefinitionForExtracts) ⇒ <code>Promise.&lt;void&gt;</code>
        * [.findSubType(templateDir, templateName)](#MetadataType+findSubType) ⇒ <code>string</code>
        * [.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex)](#MetadataType+readSecondaryFolder) ⇒ <code>Object</code>
        * [.buildDefinition(templateDir, targetDir, templateName, variables)](#MetadataType+buildDefinition) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
        * [.checkForErrors(ex)](#MetadataType+checkForErrors) ⇒ <code>string</code>
        * [.document([metadata], [isDeploy])](#MetadataType+document) ⇒ <code>void</code>
        * [.deleteByKey(customerKey)](#MetadataType+deleteByKey) ⇒ <code>boolean</code>
        * [.postDeleteTasks(customerKey)](#MetadataType+postDeleteTasks) ⇒ <code>void</code>
        * [.deleteByKeySOAP(customerKey, [handleOutside])](#MetadataType+deleteByKeySOAP) ⇒ <code>boolean</code>
        * [.readBUMetadataForType(readDir, [listBadKeys], [buMetadata])](#MetadataType+readBUMetadataForType) ⇒ <code>Object</code>
    * _static_
        * [.client](#MetadataType.client) : <code>Util.SDK</code>
        * [.properties](#MetadataType.properties) : <code>Util.MultiMetadataTypeMap</code>
        * [.subType](#MetadataType.subType) : <code>string</code>
        * [.buObject](#MetadataType.buObject) : <code>Object</code>

<a name="MetadataType+getJsonFromFS"></a>

### metadataType.getJsonFromFS(dir, [listBadKeys]) ⇒ <code>Object</code>
Returns file contents mapped to their filename without '.json' ending

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Object</code> - fileName => fileContent map  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| dir | <code>string</code> |  | directory that contains '.json' files to be read |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |

<a name="MetadataType+getFieldNamesToRetrieve"></a>

### metadataType.getFieldNamesToRetrieve([additionalFields]) ⇒ <code>Array.&lt;string&gt;</code>
Returns fieldnames of Metadata Type. 'this.definition.fields' variable only set in child classes.

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Array.&lt;string&gt;</code> - Fieldnames  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |

<a name="MetadataType+deploy"></a>

### metadataType.deploy(metadata, deployDir, retrieveDir) ⇒ <code>Promise.&lt;Object&gt;</code>
Deploys metadata

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Object&gt;</code> - Promise of keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |
| retrieveDir | <code>string</code> | directory where metadata after deploy should be saved |

<a name="MetadataType+postDeployTasks"></a>

### metadataType.postDeployTasks(metadata, originalMetadata) ⇒ <code>void</code>
Gets executed after deployment of metadata type

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| originalMetadata | <code>Util.MetadataTypeMap</code> | metadata to be updated (contains additioanl fields) |

<a name="MetadataType+postRetrieveTasks"></a>

### metadataType.postRetrieveTasks(metadata, targetDir, [isTemplating]) ⇒ <code>Util.MetadataTypeItem</code>
Gets executed after retreive of metadata type

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Util.MetadataTypeItem</code> - cloned metadata  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| targetDir | <code>string</code> | folder where retrieves should be saved |
| [isTemplating] | <code>boolean</code> | signals that we are retrieving templates |

<a name="MetadataType+overrideKeyWithName"></a>

### metadataType.overrideKeyWithName(metadata, [warningMsg]) ⇒ <code>void</code>
used to synchronize name and external key during retrieveAsTemplate

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single item |
| [warningMsg] | <code>string</code> | optional msg to show the user |

<a name="MetadataType+retrieve"></a>

### metadataType.retrieve(retrieveDir, [additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveChangelog"></a>

### metadataType.retrieveChangelog([additionalFields], [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata from Marketing Cloud

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveForCache"></a>

### metadataType.retrieveForCache([subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+retrieveAsTemplate"></a>

### metadataType.retrieveAsTemplate(templateDir, name, templateVariables, [subType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| name | <code>string</code> | name of the metadata file |
| templateVariables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| [subType] | <code>string</code> | optionally limit to a single subtype |

<a name="MetadataType+preDeployTasks"></a>

### metadataType.preDeployTasks(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeItem&gt;</code>
Gets executed before deploying metadata

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeItem&gt;</code> - Promise of a single metadata item  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | a single metadata item |
| deployDir | <code>string</code> | folder where files for deployment are stored |

<a name="MetadataType+create"></a>

### metadataType.create(metadata, deployDir) ⇒ <code>void</code>
Abstract create method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+update"></a>

### metadataType.update(metadata, [metadataBefore]) ⇒ <code>void</code>
Abstract update method that needs to be implemented in child metadata type

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [metadataBefore] | <code>Util.MetadataTypeItem</code> | metadata mapped by their keyField |

<a name="MetadataType+upsert"></a>

### metadataType.upsert(metadata, deployDir) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
MetadataType upsert, after retrieving from target and comparing to check if create or update operation is needed.

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| metadata | <code>Util.MetadataTypeMap</code> | metadata mapped by their keyField |
| deployDir | <code>string</code> | directory where deploy metadata are saved |

<a name="MetadataType+createREST"></a>

### metadataType.createREST(metadataEntry, uri) ⇒ <code>Promise</code>
Creates a single metadata entry via REST

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for POST |

<a name="MetadataType+createSOAP"></a>

### metadataType.createSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Creates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+updateREST"></a>

### metadataType.updateREST(metadataEntry, uri) ⇒ <code>Promise</code>
Updates a single metadata entry via REST

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | a single metadata Entry |
| uri | <code>string</code> | rest endpoint for PATCH |

<a name="MetadataType+updateSOAP"></a>

### metadataType.updateSOAP(metadataEntry, [overrideType], [handleOutside]) ⇒ <code>Promise</code>
Updates a single metadata entry via fuel-soap (generic lib not wrapper)

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | single metadata entry |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+retrieveSOAP"></a>

### metadataType.retrieveSOAP(retrieveDir, [requestParams], [additionalFields], [overrideType]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves SOAP via generic fuel-soap wrapper based metadata of metadata type into local filesystem. executes callback with retrieved metadata

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| [requestParams] | <code>Object</code> | required for the specific request (filter for example) |
| [additionalFields] | <code>Array.&lt;string&gt;</code> | Returns specified fields even if their retrieve definition is not set to true |
| [overrideType] | <code>string</code> | can be used if the API type differs from the otherwise used type identifier |

<a name="MetadataType+retrieveREST"></a>

### metadataType.retrieveREST(retrieveDir, uri, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Retrieves Metadata for Rest Types

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| retrieveDir | <code>string</code> | Directory where retrieved metadata directory will be saved |
| uri | <code>string</code> | rest endpoint for GET |
| [overrideType] | <code>string</code> | force a metadata type (mainly used for Folders) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+parseResponseBody"></a>

### metadataType.parseResponseBody(body) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Builds map of metadata entries mapped to their keyfields

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - keyField => metadata map  

| Param | Type | Description |
| --- | --- | --- |
| body | <code>Object</code> | json of response body |

<a name="MetadataType+deleteFieldByDefinition"></a>

### metadataType.deleteFieldByDefinition(metadataEntry, fieldPath, definitionProperty, origin) ⇒ <code>void</code>
Deletes a field in a metadata entry if the selected definition property equals false.

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | One entry of a metadataType |
| fieldPath | <code>string</code> | field path to be checked if it conforms to the definition (dot seperated if nested): 'fuu.bar' |
| definitionProperty | <code>&#x27;isCreateable&#x27;</code> \| <code>&#x27;isUpdateable&#x27;</code> \| <code>&#x27;retrieving&#x27;</code> \| <code>&#x27;templating&#x27;</code> | delete field if definitionProperty equals false for specified field. Options: [isCreateable | isUpdateable] |
| origin | <code>string</code> | string of parent object, required when using arrays as these are parsed slightly differently. |

**Example**  
```js
Removes field (or nested fields childs) that are not updateable
deleteFieldByDefinition(metadataEntry, 'CustomerKey', 'isUpdateable');
```
<a name="MetadataType+removeNotCreateableFields"></a>

### metadataType.removeNotCreateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not createable

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+removeNotUpdateableFields"></a>

### metadataType.removeNotUpdateableFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not updateable

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepTemplateFields"></a>

### metadataType.keepTemplateFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the template

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+keepRetrieveFields"></a>

### metadataType.keepRetrieveFields(metadataEntry) ⇒ <code>void</code>
Remove fields from metadata entry that are not needed in the stored metadata

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> | metadata entry |

<a name="MetadataType+isFiltered"></a>

### metadataType.isFiltered(metadataEntry, [include]) ⇒ <code>boolean</code>
checks if the current metadata entry should be saved on retrieve or not

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - true: skip saving == filtered; false: continue with saving  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Util.MetadataTypeItem</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+isFilteredFolder"></a>

### metadataType.isFilteredFolder(metadataEntry, [include]) ⇒ <code>boolean</code>
optionally filter by what folder something is in

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - true: filtered == do NOT save; false: not filtered == do save  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| metadataEntry | <code>Object</code> |  | metadata entry |
| [include] | <code>boolean</code> | <code>false</code> | true: use definition.include / options.include; false=exclude: use definition.filter / options.exclude |

<a name="MetadataType+saveResults"></a>

### metadataType.saveResults(results, retrieveDir, [overrideType], [templateVariables]) ⇒ <code>Promise.&lt;Util.MetadataTypeMap&gt;</code>
Helper for writing Metadata to disk, used for Retrieve and deploy

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;Util.MetadataTypeMap&gt;</code> - Promise of saved metadata  

| Param | Type | Description |
| --- | --- | --- |
| results | <code>Util.MetadataTypeMap</code> | metadata results from deploy |
| retrieveDir | <code>string</code> | directory where metadata should be stored after deploy/retrieve |
| [overrideType] | <code>string</code> | for use when there is a subtype (such as folder-queries) |
| [templateVariables] | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+buildDefinitionForExtracts"></a>

### metadataType.buildDefinitionForExtracts(templateDir, targetDir, metadata, variables, templateName) ⇒ <code>Promise.&lt;void&gt;</code>
helper for buildDefinition
handles extracted code if any are found for complex types (e.g script, asset, query)

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;void&gt;</code> - Promise  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>string</code> | Directory where built definitions will be saved |
| metadata | <code>Util.MetadataTypeItem</code> | main JSON file that was read from file system |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |
| templateName | <code>string</code> | name of the template to be built |

<a name="MetadataType+findSubType"></a>

### metadataType.findSubType(templateDir, templateName) ⇒ <code>string</code>
check template directory for complex types that open subfolders for their subtypes

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>string</code> - subtype name  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| templateName | <code>string</code> | name of the metadata file |

<a name="MetadataType+readSecondaryFolder"></a>

### metadataType.readSecondaryFolder(templateDir, typeDirArr, templateName, fileName, ex) ⇒ <code>Object</code>
optional method used for some types to try a different folder structure

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Object</code> - metadata  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| typeDirArr | <code>Array.&lt;string&gt;</code> | current subdir for this type |
| templateName | <code>string</code> | name of the metadata template |
| fileName | <code>string</code> | name of the metadata template file w/o extension |
| ex | <code>Error</code> | error from first attempt |

<a name="MetadataType+buildDefinition"></a>

### metadataType.buildDefinition(templateDir, targetDir, templateName, variables) ⇒ <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code>
Builds definition based on template
NOTE: Most metadata files should use this generic method, unless custom
parsing is required (for example scripts & queries)

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Promise.&lt;{metadata:Util.MetadataTypeMap, type:string}&gt;</code> - Promise of item map  

| Param | Type | Description |
| --- | --- | --- |
| templateDir | <code>string</code> | Directory where metadata templates are stored |
| targetDir | <code>String</code> \| <code>Array.&lt;String&gt;</code> | (List of) Directory where built definitions will be saved |
| templateName | <code>string</code> | name of the metadata file |
| variables | <code>Util.TemplateMap</code> | variables to be replaced in the metadata |

<a name="MetadataType+checkForErrors"></a>

### metadataType.checkForErrors(ex) ⇒ <code>string</code>
Standardizes a check for multiple messages

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>string</code> - formatted Error Message  

| Param | Type | Description |
| --- | --- | --- |
| ex | <code>Object</code> | response payload from REST API |

<a name="MetadataType+document"></a>

### metadataType.document([metadata], [isDeploy]) ⇒ <code>void</code>
Gets metadata cache with limited fields and does not store value to disk

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  

| Param | Type | Description |
| --- | --- | --- |
| [metadata] | <code>Util.MetadataTypeMap</code> | a list of type definitions |
| [isDeploy] | <code>boolean</code> | used to skip non-supported message during deploy |

<a name="MetadataType+deleteByKey"></a>

### metadataType.deleteByKey(customerKey) ⇒ <code>boolean</code>
Delete a metadata item from the specified business unit

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - deletion success status  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of data extension |

<a name="MetadataType+postDeleteTasks"></a>

### metadataType.postDeleteTasks(customerKey) ⇒ <code>void</code>
clean up after deleting a metadata item

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>void</code> - -  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata item |

<a name="MetadataType+deleteByKeySOAP"></a>

### metadataType.deleteByKeySOAP(customerKey, [handleOutside]) ⇒ <code>boolean</code>
Delete a data extension from the specified business unit

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>boolean</code> - deletion success flag  

| Param | Type | Description |
| --- | --- | --- |
| customerKey | <code>string</code> | Identifier of metadata |
| [handleOutside] | <code>boolean</code> | if the API reponse is irregular this allows you to handle it outside of this generic method |

<a name="MetadataType+readBUMetadataForType"></a>

### metadataType.readBUMetadataForType(readDir, [listBadKeys], [buMetadata]) ⇒ <code>Object</code>
Returns metadata of a business unit that is saved locally

**Kind**: instance method of [<code>MetadataType</code>](#MetadataType)  
**Returns**: <code>Object</code> - Metadata of BU in local directory  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| readDir | <code>string</code> |  | root directory of metadata. |
| [listBadKeys] | <code>boolean</code> | <code>false</code> | do not print errors, used for badKeys() |
| [buMetadata] | <code>Object</code> |  | Metadata of BU in local directory |

<a name="MetadataType.client"></a>

### MetadataType.client : <code>Util.SDK</code>
**Kind**: static property of [<code>MetadataType</code>](#MetadataType)  
<a name="MetadataType.properties"></a>

### MetadataType.properties : <code>Util.MultiMetadataTypeMap</code>
**Kind**: static property of [<code>MetadataType</code>](#MetadataType)  
<a name="MetadataType.subType"></a>

### MetadataType.subType : <code>string</code>
**Kind**: static property of [<code>MetadataType</code>](#MetadataType)  
<a name="MetadataType.buObject"></a>

### MetadataType.buObject : <code>Object</code>
**Kind**: static property of [<code>MetadataType</code>](#MetadataType)  
<a name="MultiMetadataTypeList"></a>

## MultiMetadataTypeList : <code>Object.&lt;string, string&gt;</code>
**Kind**: global typedef  
